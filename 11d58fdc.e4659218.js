(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{53:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return o})),a.d(t,"default",(function(){return s}));var n=a(2),r=a(6),i=(a(0),a(86)),l={id:"Classes"},b={unversionedId:"modules/Brix/Classes/Classes",id:"modules/Brix/Classes/Classes",isDocsHomePage:!1,title:"Classes",description:"Classes",source:"@site/docs/modules/Brix/Classes/Classes.md",slug:"/modules/Brix/Classes/Classes",permalink:"/modules/Brix/Classes/Classes",editUrl:"https://github.com/CityScope/cityscope.github.io/blob/new_docsite/docsite/docs/modules/Brix/Classes/Classes.md",version:"current"},o=[{value:"Handler class",id:"handler-class",children:[{value:"class brix.Handler(table_name, quietly=True, host_mode=&#39;remote&#39;, host_name=None, reference=None, shell_mode=False)",id:"class-brixhandlertable_name-quietlytrue-host_moderemote-host_namenone-referencenone-shell_modefalse",children:[]},{value:"Example",id:"example",children:[]}]},{value:"Indicator class",id:"indicator-class",children:[{value:"class brix.Indicator(*args, **kwargs)",id:"class-brixindicatorargs-kwargs",children:[]}]},{value:"GEOGRIDDATA class",id:"geogriddata-class",children:[{value:"class brix.GEOGRIDDATA(geogrid_data)",id:"class-brixgeogriddatageogrid_data",children:[]}]},{value:"Indicator sub-classes",id:"indicator-sub-classes",children:[{value:"class brix.CompositeIndicator(*args, **kwargs)",id:"class-brixcompositeindicatorargs-kwargs",children:[]},{value:"class brix.StaticHeatmap(*args, **kwargs)",id:"class-brixstaticheatmapargs-kwargs",children:[]}]},{value:"User class",id:"user-class",children:[{value:"class brix.User(*args, sleep_time=7, name=None, **kwargs)",id:"class-brixuserargs-sleep_time7-namenone-kwargs",children:[]}]}],c={rightToc:o};function s(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"classes"},"Classes"),Object(i.b)("h2",{id:"handler-class"},"Handler class"),Object(i.b)("h3",{id:"class-brixhandlertable_name-quietlytrue-host_moderemote-host_namenone-referencenone-shell_modefalse"},"class brix.Handler(table_name, quietly=True, host_mode='remote', host_name=None, reference=None, shell_mode=False)"),Object(i.b)("p",null,"Class to handle the connection for indicators built based on data from the GEOGRID. To use, instantiate the class and use the ",Object(i.b)("inlineCode",{parentName:"p"},"add_indicator()")," method to pass it a set of ",Object(i.b)("inlineCode",{parentName:"p"},"Indicator")," objects."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"table_name")," (",Object(i.b)("em",{parentName:"li"},"str"),") \u2013 Table name to lisen to.\n",Object(i.b)("a",{parentName:"li",href:"https://cityio.media.mit.edu/api/table/table_name"},"https://cityio.media.mit.edu/api/table/table_name"))))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **quietly** (boolean, defaults to True) \u2013 If True, it will show the status of every API call.\n\n\n* **host_mode** (*str**, **defaults to 'remote'*) \u2013 If \u2018local\u2019 it will use [http://127.0.0.1:5000/](http://127.0.0.1:5000/) as host.\n\n\n* **host_name** (*str**, **defaults to class remote_host*) \u2013 If passed, it will override the class host.\n\n\n* **reference** (*dict**, **optional*) \u2013 Dictionary for reference values for each indicator.\n\n\n* **shell_mode** (*Boolean**, **optional defaults to False*) \u2013 If True, it will not get the current hash when instantiating the class. Useful for testing.\n")),Object(i.b)("h4",{id:"geogriddata_endpoint--geogriddata"},"GEOGRIDDATA_endpoint( = 'GEOGRIDDATA')"),Object(i.b)("h4",{id:"geogrid_endpoint--geogrid"},"GEOGRID_endpoint( = 'GEOGRID')"),Object(i.b)("h4",{id:"add_geogrid_data_update_functionupdate_func"},"add_geogrid_data_update_function(update_func)"),Object(i.b)("p",null,"Adds a function to update GEOGRIDDATA."),Object(i.b)("p",null,"See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.update_geogrid_data()"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"update_func")," (",Object(i.b)("em",{parentName:"p"},"function"),") \u2013 Function to update the geogriddadata (list of dicts)\nFunction should take a ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler")," as the first and only positional argument.\nNo keyword arguments are supported when using this feature.\nFunction should return a list of dicts that represents a valid geogriddata object."))),Object(i.b)("h4",{id:"add_indicatori-testtrue"},"add_indicator(I, test=True)"),Object(i.b)("p",null,"Adds indicator to handler object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"I")," (",Object(i.b)("inlineCode",{parentName:"li"},"brix.Indicator"),") \u2013 Indicator object to handle. If indicator has name, this will use as identifier. If indicator has no name, it will generate an identifier.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **test** (boolean, defaults to True) \u2013 If True it will ensure the indicator runs before adding it to the `brix.Handler`.\n")),Object(i.b)("h4",{id:"add_indicatorsindicator_list-testtrue"},"add_indicators(indicator_list, test=True)"),Object(i.b)("p",null,"Same as ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.add_indicator()")," but it takes in a list of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator")," objects."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_list")," (",Object(i.b)("em",{parentName:"p"},"list"),") \u2013 List of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator")," objects."))),Object(i.b)("h4",{id:"classmethod-all_indicator_instances"},"classmethod all_indicator_instances()"),Object(i.b)("p",null,"Returns a generator with every indicator instance."),Object(i.b)("h4",{id:"check_tablereturn_valuefalse"},"check_table(return_value=False)"),Object(i.b)("p",null,"Prints the front end url for the table."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"return_value")," (boolean, defaults to False) \u2013 If True it will print and return the front end url."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"front_end_url")," \u2013 Onlye if return_value=True."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  str"))),Object(i.b)("h4",{id:"cityio_post_headers--content-type-applicationjson"},"cityio_post_headers( = {'Content-Type': 'application/json'})"),Object(i.b)("h4",{id:"clear_endpoints"},"clear_endpoints()"),Object(i.b)("p",null,"Clears the table of all pre-existing numeric, heatmap, and textual indicators."),Object(i.b)("h4",{id:"clear_table"},"clear_table()"),Object(i.b)("p",null,"Clears all indicators from the table."),Object(i.b)("h4",{id:"property-daemon"},"property daemon()"),Object(i.b)("p",null,"A boolean value indicating whether this thread is a daemon thread."),Object(i.b)("p",null,"This must be set before start() is called, otherwise RuntimeError is\nraised. Its initial value is inherited from the creating thread; the\nmain thread is not a daemon thread and therefore all threads created in\nthe main thread default to daemon = False."),Object(i.b)("p",null,"The entire Python program exits when only daemon threads are left."),Object(i.b)("h4",{id:"getname"},"getName()"),Object(i.b)("h4",{id:"get_geogridforce_getfalse"},"get_GEOGRID(force_get=False)"),Object(i.b)("p",null,"Returns geogrid object stored locally. If force_get=True, it will return remote object and overwrite local object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"force_get")," (boolean, defaults to False) \u2013 If True it will GET request the geogrid object and overwrite the locally stored one."))),Object(i.b)("h4",{id:"get_geogriddata"},"get_GEOGRIDDATA()"),Object(i.b)("p",null,"Returns the raw GEOGRIDDATA object.\nThis function should be treated as a low-level function, please use ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_data()")," instead."),Object(i.b)("h4",{id:"get_geogrid_edges"},"get_GEOGRID_EDGES()"),Object(i.b)("p",null,"Gets the edges of a graph that connects each cell to its nearest neighbors."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"GEOGRID_EDGES")," \u2013 Edge list of cell ids. Each cell has at most 4 neighbors."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h4",{id:"get_geogrid_datainclude_geometriesfalse-with_propertiesfalse"},"get_geogrid_data(include_geometries=False, with_properties=False)"),Object(i.b)("p",null,"Returns the geogrid data from:\n",Object(i.b)("a",{parentName:"p",href:"http://cityio.media.mit.edu/api/table/table_name/GEOGRIDDATA"},"http://cityio.media.mit.edu/api/table/table_name/GEOGRIDDATA")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"include_geometries")," (boolean, defaults to False) \u2013 If True it will also add the geometry information for each grid unit.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **with_properties** (boolean, defaults to False) \u2013 If True it will add the properties of each grid unit as defined when the table was constructed (e.g. LBCS code, NAICS code, etc.)\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_data")," \u2013 Data taken directly from the table to be used as input for ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator"),".\nObject behaves as a list of dicts."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("inlineCode",{parentName:"p"},"brix.GEOGRIDDATA")))),Object(i.b)("h4",{id:"get_geogrid_props"},"get_geogrid_props()"),Object(i.b)("p",null,"Gets the GEOGRID properties defined for the table. These properties are not dynamic and include things such as the NAICS and LBCS composition of each lego type."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_props")," \u2013 Table GEOGRID properties."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict"))),Object(i.b)("h4",{id:"get_grid_hash"},"get_grid_hash()"),Object(i.b)("p",null,"Retreives the GEOGRID hash from:\n",Object(i.b)("a",{parentName:"p",href:"http://cityio.media.mit.edu/api/table/table_name/meta/hashes"},"http://cityio.media.mit.edu/api/table/table_name/meta/hashes")),Object(i.b)("h4",{id:"get_indicator_valuesgeogrid_datanone-include_compositefalse"},"get_indicator_values(geogrid_data=None, include_composite=False)"),Object(i.b)("p",null,"Returns the current values of NUMERIC indicators. Used for developing a composite indicator."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"include_composite")," (boolean, defaults to False) \u2013 If True it will also include the composite indicators, using the ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator")," is_composite parameter."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_values")," \u2013 Dictionary with values for each indicator formatted as: ",Object(i.b)("inlineCode",{parentName:"p"},"{indicator_name: indicator_value, ...}")))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict"))),Object(i.b)("h4",{id:"get_table_properties"},"get_table_properties()"),Object(i.b)("p",null,"Gets table properties. This info can also be accessed through ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_props()"),"."),Object(i.b)("h4",{id:"grid_boundsbboxfalse-buffer_percentnone"},"grid_bounds(bbox=False, buffer_percent=None)"),Object(i.b)("p",null,"Returns the bounds of the geogrid.\nWrapper around ",Object(i.b)("inlineCode",{parentName:"p"},"brix.GEOGRIDDATA.bounds()")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"bbox")," (",Object(i.b)("em",{parentName:"li"},"boolean",Object(i.b)("strong",{parentName:"em"},", "),"defaults to False"),") \u2013 If True, it will return a bounding box instead of a polygon. ","[W, S, E, N]")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **buffer_percent** (*float**, **optional*) \u2013 If given, this will add a buffer around the table.\nSize of buffer in units of the grid diameter\nSee `brix.get_buffer_size()`.\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"limit")," \u2013 Bounds of the table. If bbox=True it will return a horizontal bounding box."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  shapely.Polygon or list"))),Object(i.b)("h4",{id:"property-ident"},"property ident()"),Object(i.b)("p",null,"Thread identifier of this thread or None if it has not been started."),Object(i.b)("p",null,"This is a nonzero integer. See the get_ident() function. Thread\nidentifiers may be recycled when a thread exits and another thread is\ncreated. The identifier is available even after the thread has exited."),Object(i.b)("h4",{id:"indicatorname"},"indicator(name)"),Object(i.b)("p",null,"Returns the ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator")," with the given name."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"name")," (",Object(i.b)("em",{parentName:"p"},"str"),") \u2013 Name of the indicator. See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.list_indicators()"),"."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"selected_indicator")," \u2013 Selected indicator object."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator")))),Object(i.b)("h4",{id:"isalive"},"isAlive()"),Object(i.b)("p",null,"Return whether the thread is alive."),Object(i.b)("p",null,"This method is deprecated, use is_alive() instead."),Object(i.b)("h4",{id:"isdaemon"},"isDaemon()"),Object(i.b)("h4",{id:"is_alive"},"is_alive()"),Object(i.b)("p",null,"Return whether the thread is alive."),Object(i.b)("p",null,"This method returns True just before the run() method starts until just\nafter the run() method terminates. The module function enumerate()\nreturns a list of all alive threads."),Object(i.b)("h4",{id:"jointimeoutnone"},"join(timeout=None)"),Object(i.b)("p",null,"Wait until the thread terminates."),Object(i.b)("p",null,"This blocks the calling thread until the thread whose join() method is\ncalled terminates \u2013 either normally or through an unhandled exception\nor until the optional timeout occurs."),Object(i.b)("p",null,"When the timeout argument is present and not None, it should be a\nfloating point number specifying a timeout for the operation in seconds\n(or fractions thereof). As join() always returns None, you must call\nis_alive() after join() to decide whether a timeout happened \u2013 if the\nthread is still alive, the join() call timed out."),Object(i.b)("p",null,"When the timeout argument is not present or None, the operation will\nblock until the thread terminates."),Object(i.b)("p",null,"A thread can be join()ed many times."),Object(i.b)("p",null,"join() raises a RuntimeError if an attempt is made to join the current\nthread as that would cause a deadlock. It is also an error to join() a\nthread before it has been started and attempts to do so raises the same\nexception."),Object(i.b)("h4",{id:"classmethod-list_all_indicator_instances"},"classmethod list_all_indicator_instances()"),Object(i.b)("p",null,"Returns a list with all indicator instances."),Object(i.b)("h4",{id:"list_all_unlinked_indicators"},"list_all_unlinked_indicators()"),Object(i.b)("p",null,"Returns the names of all the unlinked indicators."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicators_names")," \u2013 List of indicator names."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h4",{id:"list_indicators"},"list_indicators()"),Object(i.b)("p",null,"Returns list of all indicator names."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicators_names")," \u2013 List of indicator names."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h4",{id:"listennew_threadfalse-showfronttrue-appendfalse-clear_endpointsfalse"},"listen(new_thread=False, showFront=True, append=False, clear_endpoints=False)"),Object(i.b)("p",null,"Listens for changes in the table\u2019s geogrid and update all indicators accordingly.\nYou can use the update_package method to see the object that will be posted to the table.\nThis method starts with an update before listening.\nCan run in a separate thread.\nDoes not support updating GEOGRIDDATA."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"new_thread")," (boolean, defaults to False.) \u2013 If True it will run in a separate thread, freeing up the main thread for other tables.\nWe recommend setting this to False when debugging, to avoid needing to recreate the object.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **showFront** (boolean, defaults to True) \u2013 If True it will open the front-end URL in a webbrowser at start.\nOnly works if new_tread=False.\n\n\n* **append** (boolean, defaults to False) \u2013 If True it will append the new indicators to whatever is already there.\nThis option will be deprecated soon. We recommend not using it unless strictly necessary.\n\n\n* **clear_endpoints** (boolean, defaults to False) \u2013 If True, it will clear all existing heatmap, numeric, and textual indicators.\nThis is not recommended for deployment, only for testing.\n")),Object(i.b)("h4",{id:"property-name"},"property name()"),Object(i.b)("p",null,"A string used for identification purposes only."),Object(i.b)("p",null,"It has no semantics. Multiple threads may be given the same name. The\ninitial name is set by the constructor."),Object(i.b)("h4",{id:"property-native_id"},"property native_id()"),Object(i.b)("p",null,"Native integral thread ID of this thread, or None if it has not been started."),Object(i.b)("p",null,"This is a non-negative integer. See the get_native_id() function.\nThis represents the Thread ID as reported by the kernel."),Object(i.b)("h4",{id:"normalize_codescode_proportion"},"normalize_codes(code_proportion)"),Object(i.b)("p",null,"Helper function to transform:\n","[{\u2018proportion\u2019: 0.3, \u2018use\u2019: {\u20186700\u2019: 1}}, {\u2018proportion\u2019: 0.7, \u2018use\u2019: {\u20182310\u2019: 0.3, \u20184100\u2019: 0.7}}]"),Object(i.b)("p",null,"into:\n{\u20186700\u2019: 0.3, \u20182310\u2019: 0.21, \u20184100\u2019: 0.49}"),Object(i.b)("h4",{id:"parse_classificationsgeogrid"},"parse_classifications(geogrid)"),Object(i.b)("p",null,"Helper function to parse the LBCS and NAICS strings into dictionaries of the form:\n{\u20186700\u2019: 0.3, \u20182310\u2019: 0.21, \u20184100\u2019: 0.49}"),Object(i.b)("h4",{id:"perform_geogrid_data_updategeogrid_datanone"},"perform_geogrid_data_update(geogrid_data=None)"),Object(i.b)("p",null,"Performs GEOGRIDDATA update using the functions added to the ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler")," using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Hanlder.add_geogrid_data_update_function()"),"."),Object(i.b)("p",null,"Returns True if an update happened, and Flase otherwise."),Object(i.b)("p",null,"Any grid indicator will overrule any grid function."),Object(i.b)("h4",{id:"perform_updategrid_hash_idnone-appendfalse"},"perform_update(grid_hash_id=None, append=False)"),Object(i.b)("p",null,"Performs single table update."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"grid_hash_id")," (",Object(i.b)("em",{parentName:"li"},"str",Object(i.b)("strong",{parentName:"em"},", "),"optional"),") \u2013 Current grid hash id. If not provided, it will retrieve it.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **append** (boolean, defaults to True) \u2013 If True, it will append the new indicators to whatever is already there.\n")),Object(i.b)("h4",{id:"post_geogrid_datageogrid_data-override_verificationfalse"},"post_geogrid_data(geogrid_data, override_verification=False)"),Object(i.b)("p",null,"Posts the given geogrid_data object, ensuring that the object is valid."),Object(i.b)("p",null,"Function can be called by itself or using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.update_geogrid_data()"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"geogrid_data")," (",Object(i.b)("em",{parentName:"li"},"dict"),") \u2013 Dictionary corresponding to a valid ",Object(i.b)("inlineCode",{parentName:"li"},"brix.GEOGRIDDATA")," object.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **override_verification** (boolean, defaults to False) \u2013 If True, it will override the verification of the input as a valid object.\n")),Object(i.b)("h4",{id:"remote_host--httpscityiomediamitedu"},"remote_host( = '",Object(i.b)("a",{parentName:"h4",href:"https://cityio.media.mit.edu'"},"https://cityio.media.mit.edu'"),")"),Object(i.b)("h4",{id:"reset_geogrid_dataoverride_verificationtrue"},"reset_geogrid_data(override_verification=True)"),Object(i.b)("p",null,"Resets the GEOGRIDDATA endpoint to the initial value.\nIf the GEOGRIDDATA has not been updated, this will update it."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"override_verification")," (boolean, defaults to True) \u2013 If True, it will ensure the object defined in GEOGRID/features is a valid GEOGRIDDATA object.\nIf False, it will post the object in GEOGRID/features to GEOGRIDDATa without any verification."))),Object(i.b)("h4",{id:"return_indicatorindicator_name"},"return_indicator(indicator_name)"),Object(i.b)("p",null,"Returns the unformatted value returned by ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," function of the selected indicator."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_name")," (",Object(i.b)("em",{parentName:"p"},"str"),") \u2013 Name or identifier of the indicator. See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.list_indicators()")))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_value")," \u2013 Result of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," function for the selected indicator."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict or float"))),Object(i.b)("h4",{id:"rollback"},"rollback()"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler")," keeps track of the previous value of the indicators and access values.This function rollsback the current values to whatever the locally stored values are.\nSee also ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.previous_indicators()")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.previous_access()"),"."),Object(i.b)("h4",{id:"run"},"run()"),Object(i.b)("p",null,"Run method to be called by ",Object(i.b)("inlineCode",{parentName:"p"},"threading.Thread.start()"),".\nIt runs ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler._listen()"),"."),Object(i.b)("h4",{id:"see_currentindicator_typenumeric"},"see_current(indicator_type='numeric')"),Object(i.b)("p",null,"Returns the current values of the indicators posted for the table."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_type")," (str, defaults to numeric) \u2013 Type of the indicator. Choose either numeric, access, or heatmap (access and heatmap refer to the same type)."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"current_status")," \u2013 Current value of selected indicators."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict"))),Object(i.b)("h4",{id:"setdaemondaemonic"},"setDaemon(daemonic)"),Object(i.b)("h4",{id:"setnamename"},"setName(name)"),Object(i.b)("h4",{id:"set_opacityalpha-default_alpha1"},"set_opacity(alpha, default_alpha=1)"),Object(i.b)("p",null,"Sets opacity values in GEOGRID.\nTo see updates in GEOGRIDDATA, reset GEOGRIDDATA using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.reset_geogrid_data()"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"alpha")," (",Object(i.b)("em",{parentName:"li"},"float",Object(i.b)("strong",{parentName:"em"}," or "),"dict"),") \u2013 Values of opacity between 0 and 1.\nIf dict, use the types as keys and opacity as values.\nNon-specificed types will be set to default_alpha.\nIf float, this will change the opacity for all types equally.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **default_alpha** (*float**, **defaults to 1*) \u2013 Opacity value to use when type not specified in alpha.\n")),Object(i.b)("h4",{id:"set_timezone"},"set_timezone()"),Object(i.b)("p",null,"Sets the time zone of the table based on its coordinates.\nUseful for front end shadow simulation."),Object(i.b)("h4",{id:"start"},"start()"),Object(i.b)("p",null,"Start the thread\u2019s activity."),Object(i.b)("p",null,"It must be called at most once per thread object. It arranges for the\nobject\u2019s run() method to be invoked in a separate thread of control."),Object(i.b)("p",null,"This method will raise a RuntimeError if called more than once on the\nsame thread object."),Object(i.b)("h4",{id:"test_indicators"},"test_indicators()"),Object(i.b)("p",null,"Dry run over all indicators."),Object(i.b)("h4",{id:"update_geogrid_dataupdate_func-geogrid_datanone-kwargs"},"update_geogrid_data(update_func, geogrid_data=None, ","*","*","kwargs)"),Object(i.b)("p",null,"Function to update table GEOGRIDDATA."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"update_func")," (",Object(i.b)("em",{parentName:"p"},"function"),") \u2013 Function to update the geogriddadata (list of dicts)\nFunction should take a ",Object(i.b)("inlineCode",{parentName:"p"},"brix.GEOGRIDDATA")," as the first and only positional argument plus any number of keyword arguments.\nFunction should return a list of dicts that represents a valid geogriddata object."))),Object(i.b)("h3",{id:"example"},"Example"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},">>> def add_height(get_geogrid_data, levels=1):\n                for cell in geogrid_data:\n                        cell['height'] += levels\n                return geogrid_data\n>>> levels = 3\n>>> H = Handler('tablename', quietly=False)\n>>> H.update_geogrid_data(add_height, levels=levels)\n")),Object(i.b)("h4",{id:"update_packagegeogrid_datanone-appendfalse"},"update_package(geogrid_data=None, append=False)"),Object(i.b)("p",null,"Returns the package that will be posted in CityIO."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"geogrid_data")," (",Object(i.b)("em",{parentName:"li"},"dict",Object(i.b)("strong",{parentName:"em"},", "),"optional"),") \u2013 Result of ",Object(i.b)("inlineCode",{parentName:"li"},"brix.Handler.get_geogrid_data()"),". If not provided, it will be retrieved.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **append** (boolean, defaults to False) \u2013 If True, it will append the new indicators to whatever is already there.\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"new_values")," \u2013 Note that all heatmat indicators have been grouped into just one value."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h2",{id:"indicator-class"},"Indicator class"),Object(i.b)("h3",{id:"class-brixindicatorargs-kwargs"},"class brix.Indicator(","*","args, ","*","*","kwargs)"),Object(i.b)("p",null,"Parent class to build indicators from. To use, you need to define a subclass than inherets properties from this class. Doing so, ensures your indicator inherets the necessary methods and properties to connect with a CityScipe table."),Object(i.b)("h4",{id:"load_module"},"load_module()"),Object(i.b)("p",null,"User defined function. Used to load any data necessary for the indicator to run. In principle, you could do everything using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," but we encourage to separte data loading and module definition into two functions."),Object(i.b)("h4",{id:"return_baselinegeogrid_data"},"return_baseline(geogrid_data)"),Object(i.b)("p",null,"User defined function. Used to return a baseline value.\n","[This function might get deprecated]"),Object(i.b)("h4",{id:"return_indicatorgeogrid_data"},"return_indicator(geogrid_data)"),Object(i.b)("p",null,"User defined function. This function defines the value of the indicator as a function of the table state passed as geogrid_data. Function must return either a dictionary, a list, or a number. When returning a dict follow the format: ",Object(i.b)("inlineCode",{parentName:"p"},"{'name': 'Indicator_NAME', 'value': 1.00}"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_data")," (",Object(i.b)("em",{parentName:"p"},"dict"),") \u2013 Current state of the table. See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_data()"),". The content of this object will depend on the needs of the indicator. In particular, the values of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geometry")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geogrid_props"),"."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_value")," \u2013 Value of indicator or list of values. When returning a dict, please use the format ",Object(i.b)("inlineCode",{parentName:"p"},"{'name': 'Indicator Name', 'value': indicator_value}"),". When returning a list, please return a list of dictionaries in the same format."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list, dict, or float"))),Object(i.b)("h4",{id:"return_indicator_heatmapgeogrid_data"},"return_indicator_heatmap(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_numericgeogrid_data"},"return_indicator_numeric(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_textualgeogrid_data"},"return_indicator_textual(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"set_return_indicatorreturn_indicator"},"set_return_indicator(return_indicator)"),Object(i.b)("p",null,"Used to set the return_indicator method by passing a function."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"return_indicator")," (",Object(i.b)("em",{parentName:"p"},"func"),") \u2013 Function that takes geogrid_data as input."))),Object(i.b)("h4",{id:"setup"},"setup()"),Object(i.b)("p",null,"User defined function. Used to set up the main attributed of the custom indicator. Acts similar to an ",Object(i.b)("strong",{parentName:"p"},"init")," method."),Object(i.b)("h2",{id:"geogriddata-class"},"GEOGRIDDATA class"),Object(i.b)("h3",{id:"class-brixgeogriddatageogrid_data"},"class brix.GEOGRIDDATA(geogrid_data)"),Object(i.b)("p",null,"Class to package the input needed by each indicator.\nThis class extends a simple list to charge it with additional properties, if needed.\nIt\u2019s mainly used for internal purposes."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_data")," (",Object(i.b)("em",{parentName:"p"},"list"),") \u2013 List to converg to GEOGRIDDATA object."))),Object(i.b)("h4",{id:"append"},"append()"),Object(i.b)("p",null,"Append object to the end of the list."),Object(i.b)("h4",{id:"as_dfinclude_geometriesnone"},"as_df(include_geometries=None)"),Object(i.b)("p",null,"Returns the dataframe version of the geogriddata object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"include_geometries")," (",Object(i.b)("em",{parentName:"p"},"None"),") \u2013 If set, it will override the default option."))),Object(i.b)("h4",{id:"as_graphedges_onlyfalse"},"as_graph(edges_only=False)"),Object(i.b)("p",null,"Returns the geogriddata object as a networkx.Graph."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"edges_only")," (boolean, defaults to False) \u2013 If True, it will return the edgelist instead"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"G")," \u2013 Graph connecting each cell to its first neighbors.\nIf edges_only=True, returns a list of edges instead."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  networkx.Graph"))),Object(i.b)("h4",{id:"boundsbboxfalse-buffer_percentnone"},"bounds(bbox=False, buffer_percent=None)"),Object(i.b)("p",null,"Returns the bounds of the geogrid."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"bbox")," (",Object(i.b)("em",{parentName:"li"},"boolean",Object(i.b)("strong",{parentName:"em"},", "),"defaults to False"),") \u2013 If True, it will return a bounding box instead of a polygon. ","[W, S, E, N]")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **buffer_percent** (*float**, **optional*) \u2013 If given, this will add a buffer around the table.\nSize of buffer in units of the grid diameter\nSee `brix.get_buffer_size()`.\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"limit")," \u2013 Bounds of the table. If bbox=True it will return a horizontal bounding box."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  shapely.Polygon or list"))),Object(i.b)("h4",{id:"check_id_validityquietlytrue"},"check_id_validity(quietly=True)"),Object(i.b)("p",null,"Checks if all ids are in GEOGRIDDATA or if some are missing by comparing the number of unique ids of the current object with the grid size as return by ",Object(i.b)("inlineCode",{parentName:"p"},"brix.GEOGRIDDATA.grid_size()"),".\nDoes not raise an error, but returns a boolean.\nSee ",Object(i.b)("inlineCode",{parentName:"p"},"brix.GEOGRIDDATA.fill_missing_cells()")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"validity")," \u2013 If False, the number of unique ids does not match the grid size."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  boolean"))),Object(i.b)("h4",{id:"check_type_validityraise_errortrue"},"check_type_validity(raise_error=True)"),Object(i.b)("p",null,"Checks if all types in the given GEOGRIDDATA object correspond to a type defined in GEOGRID.\nThis function raises an error by default."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"raise_error")," (boolean, defaults to True) \u2013 If False, it will not raise the error by return a boolean of whether the types are valid or not."))),Object(i.b)("h4",{id:"clear"},"clear()"),Object(i.b)("p",null,"Remove all items from list."),Object(i.b)("h4",{id:"copy"},"copy()"),Object(i.b)("p",null,"Return a shallow copy of the list."),Object(i.b)("h4",{id:"count"},"count()"),Object(i.b)("p",null,"Return number of occurrences of value."),Object(i.b)("h4",{id:"extend"},"extend()"),Object(i.b)("p",null,"Extend list by appending elements from the iterable."),Object(i.b)("h4",{id:"fill_missing_cells"},"fill_missing_cells()"),Object(i.b)("p",null,"Fills missing cells from GEOGRID."),Object(i.b)("p",null,"This is useful when working only with interactive cells."),Object(i.b)("h4",{id:"get_geogrid"},"get_geogrid()"),Object(i.b)("p",null,"Get the value of GEOGRIDDATA from the corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"GEOGRID")," \u2013 Value of GEOGRID"))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict"))),Object(i.b)("h4",{id:"get_geogrid_props-1"},"get_geogrid_props()"),Object(i.b)("p",null,"Get the value of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.geogrid_props")," from the corresponding ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_props")," \u2013 Value of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.geogrid_props")))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  dict or list"))),Object(i.b)("h4",{id:"get_type_info"},"get_type_info()"),Object(i.b)("h4",{id:"get_type_set"},"get_type_set()"),Object(i.b)("p",null,"Returns set with all types defined in GEOGRID."),Object(i.b)("h4",{id:"grid_size"},"grid_size()"),Object(i.b)("p",null,"Returns size of the grid (total numer of cells)."),Object(i.b)("h4",{id:"index"},"index()"),Object(i.b)("p",null,"Return first index of value."),Object(i.b)("p",null,"Raises ValueError if the value is not present."),Object(i.b)("h4",{id:"insert"},"insert()"),Object(i.b)("p",null,"Insert object before index."),Object(i.b)("h4",{id:"link_tabletable_name"},"link_table(table_name)"),Object(i.b)("p",null,"Sets geogrid using set_geogrid.\nThis function should use if GEOGRID needs to be updated."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"table_name")," (str or ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler"),") \u2013 Name of the table or Handler object."))),Object(i.b)("h4",{id:"number_of_types"},"number_of_types()"),Object(i.b)("h4",{id:"pop"},"pop()"),Object(i.b)("p",null,"Remove and return item at index (default last)."),Object(i.b)("p",null,"Raises IndexError if list is empty or index is out of range."),Object(i.b)("h4",{id:"pop_geometries"},"pop_geometries()"),Object(i.b)("h4",{id:"remap_colors"},"remap_colors()"),Object(i.b)("p",null,"Forces the colors to match the define colors of the cell type.\nRequires that GEOGRIDDATA is set."),Object(i.b)("h4",{id:"remap_interactive"},"remap_interactive()"),Object(i.b)("p",null,"Forces the colors to match the define colors of the cell type.\nRequires that GEOGRIDDATA is set"),Object(i.b)("h4",{id:"remove"},"remove()"),Object(i.b)("p",null,"Remove first occurrence of value."),Object(i.b)("p",null,"Raises ValueError if the value is not present."),Object(i.b)("h4",{id:"remove_noninteractive"},"remove_noninteractive()"),Object(i.b)("p",null,"Remove noninteractive cells from object.\nModification is done in-place, meaning the object is modified.\nThe function will also return the object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"self")," \u2013 Modified object."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  brix.GEOGRIDDATA"))),Object(i.b)("h4",{id:"reverse"},"reverse()"),Object(i.b)("p",null,"Reverse ",Object(i.b)("em",{parentName:"p"},"IN PLACE"),"."),Object(i.b)("h4",{id:"set_classification_listclassification_list"},"set_classification_list(classification_list)"),Object(i.b)("h4",{id:"set_geogridgeogrid"},"set_geogrid(GEOGRID)"),Object(i.b)("h4",{id:"set_geogrid_edgesgeogrid_edges"},"set_geogrid_edges(GEOGRID_EDGES)"),Object(i.b)("h4",{id:"sort"},"sort()"),Object(i.b)("p",null,"Sort the list in ascending order and return None."),Object(i.b)("p",null,"The sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained)."),Object(i.b)("p",null,"If a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values."),Object(i.b)("p",null,"The reverse flag can be set to sort in descending order."),Object(i.b)("h2",{id:"indicator-sub-classes"},"Indicator sub-classes"),Object(i.b)("h3",{id:"class-brixcompositeindicatorargs-kwargs"},"class brix.CompositeIndicator(","*","args, ","*","*","kwargs)"),Object(i.b)("p",null,"Subclass used to define composite indicators. Composite indicators are functions of already defined indicators. By defining ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()"),", this class allows you to define a composite indicator by just passing an aggregation function."),Object(i.b)("h4",{id:"load_module-1"},"load_module()"),Object(i.b)("p",null,"User defined function. Used to load any data necessary for the indicator to run. In principle, you could do everything using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," but we encourage to separte data loading and module definition into two functions."),Object(i.b)("h4",{id:"return_baselinegeogrid_data-1"},"return_baseline(geogrid_data)"),Object(i.b)("p",null,"User defined function. Used to return a baseline value.\n","[This function might get deprecated]"),Object(i.b)("h4",{id:"return_indicatorindicator_values"},"return_indicator(indicator_values)"),Object(i.b)("p",null,"Applies ",Object(i.b)("inlineCode",{parentName:"p"},"brix.CompositeIndicator.compose_function")," to the indicator values to return the composite indicator."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_values")," (",Object(i.b)("em",{parentName:"p"},"dict"),") \u2013 Dictionary with indicator values. See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.get_indicator_values()"),"."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_values")," \u2013 List of one indicator."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h4",{id:"return_indicator_heatmapgeogrid_data-1"},"return_indicator_heatmap(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_numericgeogrid_data-1"},"return_indicator_numeric(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_textualgeogrid_data-1"},"return_indicator_textual(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"set_return_indicatorreturn_indicator-1"},"set_return_indicator(return_indicator)"),Object(i.b)("p",null,"Used to set the return_indicator method by passing a function."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"return_indicator")," (",Object(i.b)("em",{parentName:"p"},"func"),") \u2013 Function that takes geogrid_data as input."))),Object(i.b)("h4",{id:"setupcompose_function-selected_indicators-args-kwargs"},"setup(compose_function, selected_indicators=[], ","*","args, ","*","*","kwargs)"),Object(i.b)("p",null,"Indicator setup. This function is called upon ",Object(i.b)("strong",{parentName:"p"},"init")," so user does not need to call it independently."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"compose_function")," (",Object(i.b)("em",{parentName:"li"},"function"),") \u2013 Function to aggregate values of selected indicators. The function should be build to accept a dictionary with indicator values. See ",Object(i.b)("inlineCode",{parentName:"li"},"brix.Handler.get_indicator_values()"),".")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **selected_indicators** (*list**, **optional*) \u2013 List of indicators to use to aggregate.\n")),Object(i.b)("h3",{id:"class-brixstaticheatmapargs-kwargs"},"class brix.StaticHeatmap(","*","args, ","*","*","kwargs)"),Object(i.b)("p",null,"Wrapper to create a simple static heatmap indicator.\nThe indicator will post the given shapefile to the table."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"shapefile")," (",Object(i.b)("em",{parentName:"li"},"geopandas.GeoDataFrame",Object(i.b)("strong",{parentName:"em"}," or "),"str"),") \u2013 Shapefile with values for each point, or path to shapefile.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **columns** (*list*) \u2013 Columns to plot. If not provided, it will return all numeric columns.\nThe name of the indicator will be given by the name of the column.\n\n\n* **name** (*str**, **optional*) \u2013 Name of the indicator.\nIf not provided, it will generate a name by hashing the column names.\n\n\n* **normalize_values** (boolean, defaults to True) \u2013 If True, it will ensure all values are between 0 and 1.\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"Heatmap")," \u2013 Heatmap indicator that posts the given shapefile to the table."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  brix.Indicator"))),Object(i.b)("h4",{id:"load_module-2"},"load_module()"),Object(i.b)("p",null,"User defined function. Used to load any data necessary for the indicator to run. In principle, you could do everything using ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," but we encourage to separte data loading and module definition into two functions."),Object(i.b)("h4",{id:"return_baselinegeogrid_data-2"},"return_baseline(geogrid_data)"),Object(i.b)("p",null,"User defined function. Used to return a baseline value.\n","[This function might get deprecated]"),Object(i.b)("h4",{id:"return_indicatorgeogrid_data-1"},"return_indicator(geogrid_data)"),Object(i.b)("p",null,"User defined function. This function defines the value of the indicator as a function of the table state passed as geogrid_data. Function must return either a dictionary, a list, or a number. When returning a dict follow the format: ",Object(i.b)("inlineCode",{parentName:"p"},"{'name': 'Indicator_NAME', 'value': 1.00}"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"geogrid_data")," (",Object(i.b)("em",{parentName:"p"},"dict"),") \u2013 Current state of the table. See ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_data()"),". The content of this object will depend on the needs of the indicator. In particular, the values of ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geometry")," and ",Object(i.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geogrid_props"),"."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"indicator_value")," \u2013 Value of indicator or list of values. When returning a dict, please use the format ",Object(i.b)("inlineCode",{parentName:"p"},"{'name': 'Indicator Name', 'value': indicator_value}"),". When returning a list, please return a list of dictionaries in the same format."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list, dict, or float"))),Object(i.b)("h4",{id:"return_indicator_heatmapgeogrid_data-2"},"return_indicator_heatmap(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_numericgeogrid_data-2"},"return_indicator_numeric(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"return_indicator_textualgeogrid_data-2"},"return_indicator_textual(geogrid_data)"),Object(i.b)("p",null,"Placeholder for user to define."),Object(i.b)("h4",{id:"set_return_indicatorreturn_indicator-2"},"set_return_indicator(return_indicator)"),Object(i.b)("p",null,"Used to set the return_indicator method by passing a function."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"return_indicator")," (",Object(i.b)("em",{parentName:"p"},"func"),") \u2013 Function that takes geogrid_data as input."))),Object(i.b)("h4",{id:"setupshapefile-columnsnone-namenone-normalize_valuestrue"},"setup(shapefile, columns=None, name=None, normalize_values=True)"),Object(i.b)("p",null,"User defined function. Used to set up the main attributed of the custom indicator. Acts similar to an ",Object(i.b)("strong",{parentName:"p"},"init")," method."),Object(i.b)("h2",{id:"user-class"},"User class"),Object(i.b)("h3",{id:"class-brixuserargs-sleep_time7-namenone-kwargs"},"class brix.User(","*","args, sleep_time=7, name=None, ","*","*","kwargs)"),Object(i.b)("p",null,"Class that simulates a user doing changes to the grid."),Object(i.b)("p",null,"To use, instantiate the class, and run User.start_user().\nThis will create a new thread with a user running."),Object(i.b)("h4",{id:"add_indicatori-testtrue-1"},"add_indicator(I, test=True)"),Object(i.b)("p",null,"Adds indicator to handler object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"I")," (",Object(i.b)("inlineCode",{parentName:"li"},"brix.Indicator"),") \u2013 Indicator object to handle. If indicator has name, this will use as identifier. If indicator has no name, it will generate an identifier.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **test** (boolean, defaults to True) \u2013 If True it will ensure the indicator runs before adding it to the `brix.Handler`.\n")),Object(i.b)("h4",{id:"classmethod-getinstances"},"classmethod getinstances()"),Object(i.b)("h4",{id:"listennew_threadfalse-showfronttrue-appendfalse"},"listen(new_thread=False, showFront=True, append=False)"),Object(i.b)("p",null,"Listens for changes in the table\u2019s geogrid and update all indicators accordingly.\nYou can use the update_package method to see the object that will be posted to the table.\nThis method starts with an update before listening.\nCan run in a separate thread.\nDoes not support updating GEOGRIDDATA."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"new_thread")," (boolean, defaults to False.) \u2013 If True it will run in a separate thread, freeing up the main thread for other tables.\nWe recommend setting this to False when debugging, to avoid needing to recreate the object.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **showFront** (boolean, defaults to True) \u2013 If True it will open the front-end URL in a webbrowser at start.\nOnly works if new_tread=False.\n\n\n* **append** (boolean, defaults to False) \u2013 If True it will append the new indicators to whatever is already there.\nThis option will be deprecated soon. We recommend not using it unless strictly necessary.\n\n\n* **clear_endpoints** (boolean, defaults to False) \u2013 If True, it will clear all existing heatmap, numeric, and textual indicators.\nThis is not recommended for deployment, only for testing.\n")),Object(i.b)("h4",{id:"run-1"},"run()"),Object(i.b)("p",null,"Run method to be called by ",Object(i.b)("inlineCode",{parentName:"p"},"threading.Thread.start()"),"."),Object(i.b)("h4",{id:"start_user"},"start_user()"),Object(i.b)("h4",{id:"stop_user"},"stop_user()"),Object(i.b)("h4",{id:"update_packagegeogrid_datanone-appendfalse-1"},"update_package(geogrid_data=None, append=False)"),Object(i.b)("p",null,"Returns the package that will be posted in CityIO."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Parameters")),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"geogrid_data")," (",Object(i.b)("em",{parentName:"li"},"dict",Object(i.b)("strong",{parentName:"em"},", "),"optional"),") \u2013 Result of ",Object(i.b)("inlineCode",{parentName:"li"},"brix.Handler.get_geogrid_data()"),". If not provided, it will be retrieved.")))),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"* **append** (boolean, defaults to False) \u2013 If True, it will append the new indicators to whatever is already there.\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Returns")),Object(i.b)("p",{parentName:"li"},"  ",Object(i.b)("strong",{parentName:"p"},"new_values")," \u2013 Note that all heatmat indicators have been grouped into just one value."))),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Return type")),Object(i.b)("p",{parentName:"li"},"  list"))),Object(i.b)("h4",{id:"user_simquietlytrue"},"user_sim(quietly=True)"),Object(i.b)("p",null,"Simulates a user that changes the grid every sleep_time seconds.\nThe user flips a random cell 90% of the time, and shuffles the whole grid the other 10% of the time.\nThere is a small chance that the user will reset the grid to its original setting."),Object(i.b)("h4",{id:"user_status"},"user_status()"))}s.isMDXComponent=!0},86:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return m}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),s=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):b(b({},t),e)),a},p=function(e){var t=s(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=s(a),u=n,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||i;return a?r.a.createElement(m,b(b({ref:t},c),{},{components:a})):r.a.createElement(m,b({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=u;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b.mdxType="string"==typeof e?e:n,l[1]=b;for(var c=2;c<i;c++)l[c]=a[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);