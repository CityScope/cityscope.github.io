(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var a=n(2),i=n(6),r=(n(0),n(86)),o={id:"Examples"},l={unversionedId:"modules/Brix/Examples/Examples",id:"modules/Brix/Examples/Examples",isDocsHomePage:!1,title:"Examples",description:"Examples",source:"@site/docs/modules/Brix/Examples/Examples.md",slug:"/modules/Brix/Examples/Examples",permalink:"/modules/Brix/Examples/Examples",editUrl:"https://github.com/CityScope/cityscope.github.io/blob/new_docsite/docsite/docs/modules/Brix/Examples/Examples.md",version:"current"},s=[{value:"Short examples",id:"short-examples",children:[{value:"Numeric indicator: diversity",id:"numeric-indicator-diversity",children:[]},{value:"Composite indicator: average",id:"composite-indicator-average",children:[]},{value:"Heatmap indicator",id:"heatmap-indicator",children:[]},{value:"Textual indicator",id:"textual-indicator",children:[]},{value:"Multiple tables simultaneously",id:"multiple-tables-simultaneously",children:[]},{value:"Hybrid indicator",id:"hybrid-indicator",children:[]}]},{value:"Step by step examples",id:"step-by-step-examples",children:[{value:"Diversity of land-use indicator - step by step",id:"diversity-of-land-use-indicator---step-by-step",children:[]},{value:"Composite indicator \u2013 step by step tutorial",id:"composite-indicator--step-by-step-tutorial",children:[]},{value:"Heatmap indicator \u2013 step by step tutorial",id:"heatmap-indicator--step-by-step-tutorial",children:[]},{value:"Static-Heatmap indicator",id:"static-heatmap-indicator",children:[]}]}],c={rightToc:s};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"examples"},"Examples"),Object(r.b)("h2",{id:"short-examples"},"Short examples"),Object(r.b)("h3",{id:"numeric-indicator-diversity"},"Numeric indicator: diversity"),Object(r.b)("p",null,"Indicators are built as subclasses of the :class\u201dbrix.Indicator class, with three functions that need to be defined: ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()"),". The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," acts like an ",Object(r.b)("strong",{parentName:"p"},"init"),". It can take any argument and runs when the object is instantiated. The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()")," is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed to run ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()")," should be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," and defined as class attributes. The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," is the only required one and should take in a geogrid_data object (returned from ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_data()")," or from ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()"),") and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers. Sometimes, the indicator requires geographic information from the table to calculate it. To get geographic information from the table, set the property ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geometry")," to True (see Noise heatmap as an example)."),Object(r.b)("p",null,"The following example implements a diversity-of-land-use indicator"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nfrom brix import Handler\nfrom numpy import log\nfrom collections import Counter\n\nclass Diversity(Indicator):\n        def setup(self):\n                self.name = 'Entropy'\n\n        def load_module(self):\n                pass\n\n        def return_indicator(self, geogrid_data):\n                uses = [cell['land_use'] for cell in geogrid_data]\n                uses = [use for use in uses if use != 'None']\n                frequencies = Counter(uses)\n                total = sum(frequencies.values(), 0.0)\n                entropy = 0\n                for key in frequencies:\n                        p = frequencies[key]/total\n                        entropy += -p*log(p)\n                return entropy\n\ndiv = Diversity()\nH = Handler('dungeonmaster', quietly=False)\nH.add_indicator(div)\nH.listen()\n")),Object(r.b)("h3",{id:"composite-indicator-average"},"Composite indicator: average"),Object(r.b)("p",null,"In some settings, it might be useful to aggregate different indicators to get a average feel of what the neighborhood looks like. For this use case, brix provides a simplified CompositeIndicator class that only needs an aggregation function."),Object(r.b)("p",null,"Let\u2019s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact. We use the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.CompositeIndicator")," class for this. This class takes an aggregate function as input. This function should take the result of ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler.get_indicator_values()")," as input and returns a number. If you want to have more control over what the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.CompositeIndicator")," does you can always extend the class."),Object(r.b)("p",null,"Here is the simplest example that averages the values of three indicators:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler, CompositeIndicator\nfrom brix.examples import RandomIndicator\n\ndef innovation_average(indicator_values):\n    avg = (indicator_values['Innovation Potential']+indicator_values['Mobility Impact']+indicator_values['Economic Impact'])/3\n    return avg\n\nH = Handler('dungeonmaster')\nR = RandomIndicator()\navg_I = CompositeIndicator(innovation_average,name='Composite')\nH.add_indicators([R,avg_I])\n")),Object(r.b)("p",null,"In some cases, the aggregation function is too simple to write it again. In the example before, you can also pass it a pre-existing function, such as np.mean, making sure that you select the indicators that will be passed as input, by their name."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler, CompositeIndicator\nfrom brix.examples import RandomIndicator\nimport numpy as np\n\nH = Handler('dungeonmaster')\nR = RandomIndicator()\navg_I = CompositeIndicator(np.mean,selected_indicators=['Innovation Potential','Mobility Impact','Economic Impact'],name='Composite')\nH.add_indicators([R,avg_I])\n")),Object(r.b)("h3",{id:"heatmap-indicator"},"Heatmap indicator"),Object(r.b)("p",null,"The same class can be used to define a heatmap or accessiblity indicator, as opposed to a numeric indicator. First, set the class property ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.indicator_type")," equal to heatmap or to access. This will flag the indicator as a heatmap and will tell the Handler class what to do with it.\nSecond, make sure that the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," function returns a list of features or a geojson.\nThe example below shows an indicator that returns noise for every point in the center of a grid cell. Because this indicator needs the coordinates of table to return the geojson, it sets the property ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.requires_geometry")," to True."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nclass Noise(Indicator):\n        '''\n        Example of Noise heatmap indicator for points centered in each grid cell.\n\n        Note that this class requires the geometry of the table as input, which is why it sets:\n        requires_geometry = True\n        in the setup.\n\n        '''\n        def setup(self):\n                self.indicator_type = 'heatmap'\n                self.requires_geometry = True\n\n        def load_module(self):\n                pass\n\n        def return_indicator(self, geogrid_data):\n                features = []\n                for cell in geogrid_data:\n                        feature = {}\n                        lat,lon = zip(*cell['geometry']['coordinates'][0])\n                        lat,lon = mean(lat),mean(lon)\n                        feature['geometry'] = {'coordinates': [lat,lon],'type': 'Point'}\n                        feature['properties'] = {self.name:random()}\n                        features.append(feature)\n                out = {'type':'FeatureCollection','features':features}\n                return out\n")),Object(r.b)("h3",{id:"textual-indicator"},"Textual indicator"),Object(r.b)("p",null,"The example below annotates two randomly chosen cells with ",Object(r.b)("inlineCode",{parentName:"p"},"yes!")," and ",Object(r.b)("inlineCode",{parentName:"p"},"no!"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nimport random\nclass RandomFlag(Indicator):\n        '''\n        Example of textual indicator that annotates two random cells.\n        '''\n        def setup(self):\n                self.indicator_type = 'textual'\n                self.requires_geometry = True\n                self.name = 'Yes/No'\n\n        def return_indicator(self, geogrid_data):\n                cells = random.sample(geogrid_data,2)\n                out = [\n                        {'id':cells[0]['id'],'info':'yes!'},\n                        {'id':cells[1]['id'],'info':'no!'},\n                ]\n                return out\n")),Object(r.b)("h3",{id:"multiple-tables-simultaneously"},"Multiple tables simultaneously"),Object(r.b)("p",null,"The following examples instantiates three ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler")," objects for three different tables (dungeonA, dungeonB, and dungeonC) and adds a diversity of land use indicator to each. It then runs ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler.listen()")," for each table in its own separate thread."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler\nfrom brix.examples import Diversity, RandomIndicator\n\ntable_list = ['dungeona','dungeonb','dungeonc']\n\nhandler_list = []\nfor table_name in table_list:\n        H = Handler(table_name)\n        div = Diversity()\n        rand = RandomIndicator()\n        H.add_indicators([div,rand])\n        handler_list.append(H)\n\nfor h in handler_list:\n        h.listen()\n")),Object(r.b)("h3",{id:"hybrid-indicator"},"Hybrid indicator"),Object(r.b)("p",null,"For more complex uses cases, where a module runs a big simulation and wants to show both a heatmap and a numeric indicator, you can use a hybrid indicator. To start, set:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"self.indicator_type = 'hybrid'\n")),Object(r.b)("p",null,"If you set your indicator as hybrid you need to define a numeric and a heatmap part. The following example generates a heatmap with noise and the average noise as a numeric indicator."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nfrom numpy import mean\nimport random\nclass HybridNoise(Indicator):\n        def setup(self):\n                self.indicator_type = 'hybrid'\n                self.name = 'noise'\n                self.requires_geometry = True\n                self.mynoise = None\n\n        def return_indicator_heatmap(self, geogrid_data):\n                features = []\n                for cell in geogrid_data:\n                        feature = {}\n                        lat,lon = zip(*cell['geometry']['coordinates'][0])\n                        lat,lon = mean(lat),mean(lon)\n                        feature['geometry'] = {'coordinates': [lat,lon],'type': 'Point'}\n                        feature['properties'] = {self.name:random.random()}\n                        features.append(feature)\n                self.mynoise = features\n                out = {'type':'FeatureCollection','features':features}\n                return out\n\n        def return_indicator_numeric(self, geogrid_data):\n                mean_noise = mean([cell['properties'][self.name] for cell in self.mynoise])\n                return mean_noise\n")),Object(r.b)("p",null,"By default, brix will run the heatmap indicator first, followed by the numeric indicator. If you need more control over how these functions interact with each other, you can always re-define the return_indicator function. If you choose to do so, make sure that it returns a dictionary with two keys (\u2018heatmap\u2019 and \u2018numeric\u2019):"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"{'heatmap': heatmap_values, 'numeric': numeric_values}\n")),Object(r.b)("p",null,"In the previous example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"def return_indicator(self, geogrid_data):\n        out = {}\n        out['heatmap'] = self.return_indicator_heatmap(geogrid_data)\n        out['numeric'] = self.return_indicator_numeric(geogrid_data)\n        return out\n")),Object(r.b)("h2",{id:"step-by-step-examples"},"Step by step examples"),Object(r.b)("h3",{id:"diversity-of-land-use-indicator---step-by-step"},"Diversity of land-use indicator - step by step"),Object(r.b)("p",null,"As an example, we\u2019ll build a diversity of land use indicator for the test table. The process is the same for any table, provided that it has a GEOGRID variable. Indicators are built as subclasses of the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator")," class, with three functions that need to be defined: ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()"),", ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()"),". The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," acts like an ",Object(r.b)("strong",{parentName:"p"},"init"),". It can take any argument and runs when the object is instantiated. The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()")," is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed to run ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.load_module()")," should be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.setup()")," and defined as class attributes. The function ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," is the only required one and should take in a geogrid_data object (returned from ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler.get_geogrid_data()")," or from ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()"),") and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers."),Object(r.b)("p",null,"To start developing the diversity indicator, you can use the Handler class to get the ",Object(r.b)("inlineCode",{parentName:"p"},"geogrid_data")," that is an input of the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," function."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler\nH = Handler('dungeonmaster')\ngeogrid_data = H.geogrid_data()\n")),Object(r.b)("p",null,"The returned ",Object(r.b)("inlineCode",{parentName:"p"},"geogrid_data")," object depends on the table, but for dungeonmaster it looks like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"[\n        {\n                'color': [0, 0, 0, 0],\n                'height': 0.1,\n                'id': 0,\n                'interactive': True,\n                'land_use': 'None',\n                'name': 'empty',\n                'tui_id': None\n        },\n        {\n                'color': [247, 94, 133, 180],\n                'height': [0, 80],\n                'id': 1,\n                'interactive': True,\n                'land_use': 'PD',\n                'name': 'Office Tower',\n                'old_color': [133, 94, 247, 180],\n                'old_height': [0, 10],\n                'tui_id': None\n        },\n        {\n                'color': [0, 0, 0, 0],\n                'height': 0.1,\n                'id': 2,\n                'interactive': True,\n                'land_use': 'None',\n                'name': 'empty',\n                'tui_id': None\n        },\n        ...\n]\n")),Object(r.b)("p",null,"We build the diversity indicator by delecting the ",Object(r.b)("inlineCode",{parentName:"p"},"land_use")," variable in each cell and calculating the Shannon Entropy for this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from numpy import log\nfrom collections import Counter\nuses = [cell['land_use'] for cell in geogrid_data]\nuses = [use for use in uses if use != 'None']\n\nfrequencies = Counter(uses)\n\ntotal = sum(frequencies.values(), 0.0)\nentropy = 0\nfor key in frequencies:\n        p = frequencies[key]/total\n        entropy += -p*log(p)\n")),Object(r.b)("p",null,"Now, we wrap this calculation in the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.return_indicator()")," in a Diversity class that inherits the properties from the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator")," class:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nfrom numpy import log\nfrom collections import Counter\n\nclass Diversity(Indicator):\n\n        def setup(self):\n                self.name = 'Entropy'\n\n        def load_module(self):\n                pass\n\n        def return_indicator(self, geogrid_data):\n                uses = [cell['land_use'] for cell in geogrid_data]\n                uses = [use for use in uses if use != 'None']\n\n                frequencies = Counter(uses)\n\n                total = sum(frequencies.values(), 0.0)\n                entropy = 0\n                for key in frequencies:\n                        p = frequencies[key]/total\n                        entropy += -p*log(p)\n\n                return entropy\n")),Object(r.b)("p",null,"Because this indicator is very simple, it does not need any parameters or data to calculate the value, which is why the ",Object(r.b)("inlineCode",{parentName:"p"},"load_module")," function is empty. The ",Object(r.b)("inlineCode",{parentName:"p"},"setup")," function defines the properties of the module, which in this case is just the name."),Object(r.b)("p",null,"Finally, we run the indicator by instantiating the new class and passing it to a Handler object:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler\n\ndiv = Diversity()\n\nH = Handler('dungeonmaster', quietly=False)\nH.add_indicator(div)\nH.listen()\n")),Object(r.b)("h3",{id:"composite-indicator--step-by-step-tutorial"},"Composite indicator \u2013 step by step tutorial"),Object(r.b)("p",null,"Let\u2019s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact.\nFirst, we load the RandomIndicator and pass it to a Handler."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler, CompositeIndicator\nfrom brix.examples import RandomIndicator\n\nH = Handler('dungeonmaster')\nR = RandomIndicator()\nH.add_indicator(R)\n")),Object(r.b)("p",null,"To develop the aggregate function, we use the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler.get_indicator_values")," function from the handler class. We need to make sure our aggregate function works with that the Handler is returning:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"indicator_values = H.get_indicator_values()\n")),Object(r.b)("p",null,"In this case, the ",Object(r.b)("inlineCode",{parentName:"p"},"indicator_values")," is a dictionary with the following elements:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"{\n        'Social Wellbeing': 0.9302328967423512,\n        'Environmental Impact': 0.8229183561962108,\n        'Mobility Impact': 0.3880460148817071,\n        'Economic Impact': 0.13782084927373295,\n        'Innovation Potential': 0.8913823890081203\n}\n")),Object(r.b)("p",null,"We do not need to use all of the values returned by the Handler for our indicator."),Object(r.b)("p",null,"Next, we write our simple average function that takes ",Object(r.b)("inlineCode",{parentName:"p"},"indicator_values")," as input and returns a value, and pass it as an argument to the ",Object(r.b)("inlineCode",{parentName:"p"},"brix.CompositeIndicator")," class constructor."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"def innovation_average(indicator_values):\n        avg = (indicator_values['Innovation Potential']+indicator_values['Mobility Impact']+indicator_values['Economic Impact'])/3\n        return avg\n\navg_I = CompositeIndicator(innovation_average,name='Composite')\n")),Object(r.b)("p",null,"To make sure it is running, we can test it as usual:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"avg_I.return_indicator(indicator_values)\n")),Object(r.b)("p",null,"We finally add it to the Handler:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"H.add_indicator(avg_I)\n")),Object(r.b)("h3",{id:"heatmap-indicator--step-by-step-tutorial"},"Heatmap indicator \u2013 step by step tutorial"),Object(r.b)("p",null,"This section will show you step by step how to build a proximity to parks indicator."),Object(r.b)("p",null,"Let\u2019s start by setting up a simple subclass of the Indicator class, give it a name, and set it as a ",Object(r.b)("inlineCode",{parentName:"p"},"heatmap")," indicator:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nclass ProximityIndicator(Indicator):\n        def setup(self):\n                self.name = 'Parks'\n                self.indicator_type = 'heatmap'\n\n        def return_indicator(self, geogrid_data):\n                pass\n")),Object(r.b)("p",null,"Next, we link it to the table. This step is only for building the indicator as we use a ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Handler")," object when deploying it."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"P = ProximityIndicator()\nP.link_table('dungeonmaster')\nP.get_geogrid_data()\n")),Object(r.b)("p",null,"When running ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()")," we see that every cell has a ",Object(r.b)("inlineCode",{parentName:"p"},"name")," property and some cells are classified as ",Object(r.b)("inlineCode",{parentName:"p"},"Park"),". You\u2019ll also notice that by default, when building a ",Object(r.b)("inlineCode",{parentName:"p"},"heatmap")," indicator, ",Object(r.b)("inlineCode",{parentName:"p"},"geogrid_data")," returns the geometries. You can change this behavior by setting ",Object(r.b)("inlineCode",{parentName:"p"},"self.requires_geometry=False")," in your ",Object(r.b)("inlineCode",{parentName:"p"},"setup"),"."),Object(r.b)("p",null,"Next, we define the ",Object(r.b)("inlineCode",{parentName:"p"},"return_indicator")," function. For debugging and testing you can define this function as stand alone function before adding it as a method to the ProximityIndicator. Some useful functions for debugging are ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_geogrid_data()")," and ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator.get_table_properties()")," that will list general properties of the linked table."),Object(r.b)("p",null,"In this example, the proximity indicator is defined as one over the distance to the closest park. When the cell is a park, we define the proximity as 1/(half size of each cell) to avoid dividing by zero."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import numpy as np\nfrom geopy.distance import distance as geodistance # Function for distance between coordinates\n\ndef return_indicator(self,geogrid_data):\n        parks = [cell for cell in geogrid_data if cell['name']=='Park'] # Find all parks\n        parks_locations = [np.mean(cell['geometry']['coordinates'][0],0) for cell in parks] # Filter out the center of all park locations (locations are lon,lat format)\n\n        features = []\n        for cell in geogrid_data: # Calculate a value for the indicator for each cell\n                cell_coords = np.mean(cell['geometry']['coordinates'][0],0) # Calculate center of cell (locations are lon,lat format)\n                if cell['name']=='Park': # If cell is park, set distance to zero\n                        park_distance = 25 # This is based on half the cell size (see P.get_table_properties())\n                else:\n                        distances = [geodistance(cell_coords[::-1],park_loc[::-1]).m for park_loc in parks_locations] # Distance between cell and each park. Notice that we reverse the coordinates for geodistance.\n                        park_distance = min(distances) # get distance to closest park\n\n                proximity = 1/park_distance\n                scaled_proximity = (proximity-0.002)/(0.03-0.002) # this ensures the indicator is between zero and one\n\n                # Generate feature with points (lon,lat format) and properties.\n                feature = {}\n                feature['geometry'] = {'coordinates': list(cell_coords),'type': 'Point'} # cell_coords should be a list\n                feature['properties'] = {self.name: scaled_proximity} # Use the indicator name to tag the value\n\n                features.append(feature) # add to features list for export\n\n        out = {'type':'FeatureCollection','features':features}\n        return out\n")),Object(r.b)("p",null,"You can test your function by running: ",Object(r.b)("inlineCode",{parentName:"p"},"return_indicator(P,geogrid_data)"),"."),Object(r.b)("p",null,"Finally, let\u2019s put it all together:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Indicator\nimport numpy as np\nfrom geopy.distance import distance as geodistance\n\nclass ProximityIndicator(Indicator):\n        def setup(self):\n                self.name = 'Parks'\n                self.indicator_type = 'heatmap'\n\n        def return_indicator(self,geogrid_data):\n                parks = [cell for cell in geogrid_data if cell['name']=='Park']\n                parks_locations = [np.mean(cell['geometry']['coordinates'][0],0) for cell in parks]\n\n                features = []\n                for cell in geogrid_data:\n                        cell_coords = list(np.mean(cell['geometry']['coordinates'][0],0) )\n                        if cell['name']=='Park':\n                                park_distance = 45\n                        else:\n                                distances = [geodistance(cell_coords[::-1],park_loc[::-1]).m for park_loc in parks_locations]\n                                park_distance = min(distances)\n\n                        proximity = 1/park_distance\n                        scaled_proximity = (proximity-0.002)/(0.03-0.002)\n\n                        feature = {}\n                        feature['geometry'] = {'coordinates': cell_coords,'type': 'Point'}\n                        feature['properties'] = {self.name: scaled_proximity}\n\n                        features.append(feature)\n\n                out = {'type':'FeatureCollection','features':features}\n                return out\n")),Object(r.b)("p",null,"And to deploy it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler\nH = Handler('dungeonmaster')\nP = ProximityIndicator()\nH.add_indicator(P)\nH.listen()\n")),Object(r.b)("h3",{id:"static-heatmap-indicator"},"Static-Heatmap indicator"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"brix.Indicator")," class provides a flexible way to define any type of indicator. In some cases, a simple approach is needed. Let\u2019s assume we want to build a simple heatmap indicator that just visualizes a given shapefile, and does not react to changes in geogriddata. We can use ",Object(r.b)("inlineCode",{parentName:"p"},"brix.StaticHeatmap")," to build that."),Object(r.b)("p",null,"In this example, we will use the number of houses by block in Guadalajara, Mexico. You can download the shapefile from ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.inegi.org.mx/contenidos/masiva/indicadores/inv/14_Manzanas_INV2016_shp.zip"}),"HERE"),". We will not be using our trusted dungeonmaster table, as it does not overlap with the data. Instead we will use jalisco."),Object(r.b)("p",null,"The first step will be to \u201cgriddify\u201d our shapefile, meaning we will transform it from polygons to sampling points. Please note that you can use any sampling method for this, and that the sampling points do not need to match the grid. To make things easier, we have provided ",Object(r.b)("inlineCode",{parentName:"p"},"brix.griddify()"),", which uses the centroids of the grid to sample the values of the heatmap."),Object(r.b)("p",null,"We start by loading the shapefile and removing the missing values:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import geopandas as gpd\nshapefile = gpd.read_file('/Users/username/Downloads/14_Manzanas_INV2016_shp/14_Manzanas_INV2016.shp')\nshapefile = shapefile[shapefile['VIVTOT']!='N.D.']\nshapefile['VIVTOT'] = shapefile['VIVTOT'].astype(float)\n")),Object(r.b)("p",null,"Since the VIVTOT column that we are interested in visualizing has a skewed distribution, we will log-transform it."),Object(r.b)("p",null,"::"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import numpy as np\nshapefile[\u2018log_VIVTOT\u2019] = np.log(shapefile[\u2018VIVTOT\u2019]+1)\n")),Object(r.b)("p",null,"Next, we load a table and use its grid to sample the heatmap."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler\nH = Handler('jalisco')\ngeogrid_data = H.get_geogrid_data()\n")),Object(r.b)("p",null,"The next step is to use the grid to sample the values of the heatmap. We will use the log_VIVTOT column, and save the resulting heatmap to a file so we can load it later. We will also remove the missing values."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import griddify\nheatmap = griddify(geogrid_data,shapefile,columns=['log_VIVTOT'])\nheatmap = heatmap[~heatmap['log_VIVTOT'].isna()]\nheatmap.to_file('/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp')\n")),Object(r.b)("p",null,"This shapefile is a table of points and their properties. To build your indicator you can either load the file and pass it to the :class:brix.StaticHeatmap","`"," constructor, or have the constructor load it for you."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import StaticHeatmap\nN = StaticHeatmap('/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp',columns=['log_VIVTOT'])\n")),Object(r.b)("p",null,"Finally, we add it to a Handler class and check the update package:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"H = Handler('jalisco')\nH.add_indicator(N)\nH.update_package()\n")),Object(r.b)("p",null,"To sum up, to preprocess the data:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import geopandas as gpd\nimport numpy as np\nfrom brix import Handler\nfrom brix import griddify\n\nshapefile = gpd.read_file('/Users/username/Downloads/14_Manzanas_INV2016_shp/14_Manzanas_INV2016.shp')\nshapefile = shapefile[shapefile['VIVTOT']!='N.D.']\nshapefile['VIVTOT'] = shapefile['VIVTOT'].astype(float)\nshapefile['log_VIVTOT'] = np.log(shapefile['VIVTOT']+1)\n\n\nH = Handler('jalisco')\ngeogrid_data = H.get_geogrid_data()\nheatmap = griddify(geogrid_data,shapefile,columns=['log_VIVTOT'],buffer_percent=3)\nheatmap = heatmap[~heatmap['log_VIVTOT'].isna()]\nheatmap.to_file('/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp')\n")),Object(r.b)("p",null,"And once the heatmap file has been saved, all you need to do deploy the indicator is:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"from brix import Handler, StaticHeatmap\nN = StaticHeatmap('/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp',columns=['log_VIVTOT'])\nH = Handler('jalisco')\nH.add_indicator(N)\nH.listen()\n")))}d.isMDXComponent=!0},86:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),d=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),b=a,m=p["".concat(o,".").concat(b)]||p[b]||u[b]||r;return n?i.a.createElement(m,l(l({ref:t},c),{},{components:n})):i.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);