<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.64">
<title data-react-helmet="true">Tutorial | Here We Build CityScope</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Tutorial | Here We Build CityScope"><meta data-react-helmet="true" name="description" content="Tutorial"><meta data-react-helmet="true" property="og:description" content="Tutorial"><meta data-react-helmet="true" property="og:url" content="https://cityscope.media.mit.edu/modules/Brix/Tutorial/Tutorial"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://cityscope.media.mit.edu/modules/Brix/Tutorial/Tutorial"><link rel="stylesheet" href="/styles.febefb0e.css">
<link rel="preload" href="/styles.ca97067b.js" as="script">
<link rel="preload" href="/runtime~main.81a53239.js" as="script">
<link rel="preload" href="/main.3dd27073.js" as="script">
<link rel="preload" href="/1.0436ce2f.js" as="script">
<link rel="preload" href="/2.5a76e39d.js" as="script">
<link rel="preload" href="/30.bbda0e72.js" as="script">
<link rel="preload" href="/935f2afb.3e860e5c.js" as="script">
<link rel="preload" href="/17896441.cc98e1ce.js" as="script">
<link rel="preload" href="/1c356875.afc84696.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/ML_logo.png" alt="Logo"><strong class="navbar__title">MIT CityScope</strong></a><a class="navbar__item navbar__link" href="/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/CityScope" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link" src="img/">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/ML_logo.png" alt="Logo"><strong class="navbar__title">MIT CityScope</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">Docs</a></li><li class="menu__list-item"><a href="https://github.com/CityScope" target="_blank" rel="noopener noreferrer" class="menu__link" src="img/">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Tutorial</h1></header><div class="markdown"><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="tutorial"></a>Tutorial<a aria-hidden="true" tabindex="-1" class="hash-link" href="#tutorial" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="basics-of-building-a-cityscope-indicator"></a>Basics of building a CityScope indicator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#basics-of-building-a-cityscope-indicator" title="Direct link to heading">#</a></h2><p>Letâ€™s get to it. First, what table are you building for? If you donâ€™t have a specific table, that is totally okay and you can create one <a href="https://cityscope.media.mit.edu/CS_cityscopeJS/#/editor" target="_blank" rel="noopener noreferrer">here</a>. Note: by the time you read this, CityScope might pose some limitations on new projects (<code>tables</code>). Please follow instructions in the link above.
For this tutorial, we crated one called <code>dungeonmaster</code>.</p><p>After creating a table, open the frond end given by the tool and edit the table at least once. Change some blocks, and push those changes to CityIO.</p><p>An indicator will take in data and produce a result. Depending on the type of indicator you are building, the result can be a number, a heatmap, an annotation, or a complex simulation of agents moving around the screen. If you are building a very complex module, your indicator might return all of the above. Each new indicator is built as an subclass of the <code>brix.Indicator</code> class provided in this library. Make sure you define three functions: <code>brix.Indicator.setup()</code>, <code>brix.Indicator.load_module()</code>, and <code>brix.Indicator.return_indicator()</code>. Hereâ€™s a barebones example of an indicator:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix import Indicator</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class MyIndicator(Indicator):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Write a description for your indicator here.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        def setup(self):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                Think of this as your __init__.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                Here you will define the properties of your indicator.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                Although there are no required properties, be nice and give your indicator a name.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                self.name = &#x27;My numeric indicator&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.indicator_type = &#x27;numeric&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.viz_type = &#x27;radar&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        def load_module(self):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                This function is not strictly necessary, but we recommend that you define it if you want to load something from memory. It will make your code more readable.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                All data loading actions should go here.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                pass</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        def return_indicator(self, geogrid_data):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                This is the main course of your indicator.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                This function takes in `geogrid_data` and returns the value of your indicator.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                The library is flexible enough to handle indicators that return a number or a dictionary.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                &#x27;&#x27;&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return 1</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="lets-talk-data-input"></a>Letâ€™s talk data (input)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#lets-talk-data-input" title="Direct link to heading">#</a></h2><p>What is <code>geogrid_data</code>?
Every time we create a CityScope table, we define a regularly spaced grid which is overlaid on the city district weâ€™re modelling. These grid cells are the basic unit of analysis for the CityScope modules. Every grid cell has properties such as the <code>Type</code> which represents the land use and <code>Height</code> which represents the number of floors. These data are dynamic and are updated each time a user interacts with the CityScope table, experimenting with the spatial organisation of land uses and infrastructure. These dynamic data are stored the variable geogrid_data. This is a list of ojects: one for each grid cell in the CityScope table. The contents of each object really depends on the specific table you are building for and on the properties assigned to your indicator. There are two options that will control what geogrid_data contains which are: <code>brix.Indicator.requires_geometry</code> and <code>brix.Indicator.requires_geogrid_props</code>. These two properties are set to <code>False</code> by default, but you can change them inside the <code>brix.Indicator.setup()</code> function depending on the needs of your indicator.</p><p>To access <code>geogrid_data</code> you will need to instantiate a <code>brix.Handler</code> object that will handle all communication with the table. Go ahead, take a look at how this object looks like by creating a <code>brix.Handler</code> and linking it to a table:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix import Handler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(&#x27;dungeonmaster&#x27;,quietly=False)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.get_geogrid_data()</span></div></div></div></div></div><p>By default, each <code>brix.Handler</code> is set to work quietly in the background. If you wish to get feedback on what your Handler is doing, you can set <code>quietly=False</code> when you create your Handler. This is useful for debugging.</p><p>Bear in mind that the endpoint <code>GEOGRIDDATA</code> is created only after your first edit to the table. If you just created your table, you need to go to the front end and edit the table at least once for <code>GEOGRIDDATA</code> to show up.</p><p>The function <code>brix.Handler.get_geogrid_data()</code> accepts to optional keyword arguments <code>include_geometries</code> and <code>with_properties</code>. These arguments correspond to <code>brix.Indicator.requires_geometry</code> and <code>brix.Indicator.requires_geogrid_props</code> parameters defined in the Indicator <code>setup</code> function. For example, if <code>requires_geogrid_props=True</code> in the setup, and the Indicator is linked to the table, the Handler will know to return <code>geogrid_data</code> with <code>with_properties=True</code>.</p><p>Go ahead and see how <code>geogrid_data</code> would look like if you set <code>requires_geometry=True</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.get_geogrid_data(include_geometries=True)</span></div></div></div></div></div><p>Please note that <code>geogrid_data</code> behaves very much like a list of dictionaries, but it is not a list. It belongs to the class <code>brix.GEOGRIDDATA</code>, which is an extension of a list to include additional functions and properties related to the table. For example, you can get the meta-properties of the table (such as type definitions, location, etc.) by using <code>brix.GEOGRIDDATA.get_geogrid_props()</code>. This is useful if, for example, you are interested in counting the total number of block types, including those that are not currently on the table. Run the following example to see how geogrid_props looks like:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data = H.get_geogrid_data()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data.get_geogrid_props()</span></div></div></div></div></div><p>Depending on the needs of your indicator, you can generate different views of this object. For example, you can use <code>brix.GEOGRIDDATA.as_df()</code> to return the pandas.DataFrame version of your object. Similarly, you can use <code>brix.GEOGRIDDATA.as_graph()</code> to return the networkx.Graph representation of GEOGRIDDATA. The graph representation is the network connecting every cell to its 4 closest neighbors.</p><p>Try seeing your <code>geogrid_data</code> as a pandas.DataFrame:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data = H.get_geogrid_data()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data.as_df()</span></div></div></div></div></div><p>Additionally, you can remove non-interactive cells from <code>geogrid_data</code> by using <code>brix.GEOGRIDDATA.remove_noninteractive()</code> and get the table bounds by using <code>brix.GEOGRIDDATA.bounds()</code>.</p><p>The following example gets a grid, remove all non interactive cells and transforms it to a dataframe:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix import Handler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(&#x27;dungeonmaster&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data = H.get_geogrid_data()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data = geogrid_data.remove_noninteractive()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data.as_df()</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="build-and-test-your-indicator-output"></a>Build and test your indicator (output)<a aria-hidden="true" tabindex="-1" class="hash-link" href="#build-and-test-your-indicator-output" title="Direct link to heading">#</a></h2><p>This library ensures that you can focus on what you do best: writing a kick ass <code>brix.Indicator.return_indicator()</code> function that will make everyoneâ€™s urban planning life better.</p><p>To recap, an indicator is build by defining at least a <code>brix.Indicator.setup()</code> function that takes care of configuring the indicator and a <code>brix.Indicator.return_indicator()</code> that will calculate the value of the indicator for a given <code>geogrid_data</code>.</p><p>Hereâ€™s an example of simple <code>brix.Indicator.setup()</code> and <code>brix.Indicator.return_indicator()</code> functions for a numeric indicator:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def setup(self):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.name = &#x27;My numeric indicator&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.indicator_type = &#x27;numeric&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        self.viz_type = &#x27;radar&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">def return_indicator(self,geogrid_data):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 1</span></div></div></div></div></div><p>To test your <code>brix.Indicator.return_indicator()</code> function while debugging it, you can use the object returned by <code>brix.Handler.get_geogrid_data()</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(&#x27;dungeonmaster&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">geogrid_data = H.get_geogrid_data()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">I.return_indicator(geogrid_data)</span></div></div></div></div></div><p>Brix distinguish between four different types of indicators defined using the attribute <code>brix.Indicator.indicator_type</code> defined in <code>brix.Indicator.setup()</code>: <code>numeric</code>, <code>heatmap</code>, <code>textual</code>, and <code>hybrid</code>.</p><p><code>indicator_type=&#x27;numeric&#x27;</code> is the default and refers to a simple numeric indicator (e.g. average, density, diversity, etc.). When defining a numeric indicator, there are multiple ways in which the front end can display them (e.g. bar chart, radar plot, etc.). This is controlled by the <code>brix.Indicator.viz_type</code> attribute, also defined in the <code>brix.Indicator.setup()</code>. The default value is set to <code>self.viz_type=radar</code> which means that unless it is specified otherwise, all numeric indicators will be added to the radar plot. For a <code>numeric</code> indicator, the <code>brix.Indicator.return_indicator()</code> function can simply return a number or a list of numbers, all of which will be added to the same front end visualization (e.g. all bar charts, all radar numbers). If you want to have more fine control of where each indicator is displayed, we recommend building your <code>brix.Indicator.return_indicator()</code> function such that it returns a dictionary with the following structure:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">[</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        {&#x27;name&#x27;: &#x27;Social Wellbeing&#x27;, &#x27;value&#x27;: 0.3, &#x27;viz_type&#x27;: &#x27;radar&#x27;},</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        {&#x27;name&#x27;: &#x27;Environmental Impact&#x27;, &#x27;value&#x27;: 0.1, &#x27;viz_type&#x27;: &#x27;radar&#x27;},</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        {&#x27;name&#x27;: &#x27;Mobility Impact&#x27;, &#x27;value&#x27;: 0.5, &#x27;viz_type&#x27;: &#x27;bar&#x27;}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">]</span></div></div></div></div></div><p>Note that if you define <code>viz_type</code> in the return dictionary of <code>return_indicator</code>, it will overwrite any default property defined in <code>brix.Indicator.setup()</code>.</p><p><code>indicator_type=&#x27;heatmap&#x27;</code> refers to a heatmap indicator that will be displayed not in a chart but projected directly on the table (e.g. density, traffic congestion, etc.). For a <code>heatmap</code> indicator, the <code>brix.Indicator.return_indicator()</code> function should return a geojson of points with attributes, or a geopandas.GeoDataFrame also with points and attributes. This type of indicator is a bit more complicated to build and will often require knowledge of spatial analytics. See the examples if you are interested.</p><p><code>indicator_type=&#x27;textual&#x27;</code> refers to an indicator that is displayed as a text annotation in one of the cells. This can be used to highlight something important about that cell to the front end user. For a <code>textual</code> indicator, the <code>brix.Indicator.return_indicator()</code> function should return a list of dictionaries, each with two keys, <code>id</code> that identified the cell to annotate, and <code>info</code> with a string that will be projected over that cell in the front end. Hereâ€™s an example of a list that annotated cell <code>450</code> with <code>yes!</code> and cell <code>40</code> with <code>no!</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">[{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;id&quot;: 450,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;info&quot;: &quot;yes!&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">},{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;id&quot;: 40,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;info&quot;: &quot;no!&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}]</span></div></div></div></div></div><p>Finally, <code>indicator_type=&#x27;hybrid&#x27;</code> is used when building a very complex module that returns information to be displayed in multiple different formats. Think of a complex energy usage simulation that will display the total energy consumed as bar in the bar chart, that will show the energy used by each cell projected on the table as a heatmap, and that might annotate some cells when they do not have enough energy available to them. For a <code>hybrid</code> indicators, you have two ways of organization your code. You can define your own <code>brix.Indicator.return_indicator()</code> function, or you can define specific functions for each of the available types of indicators: <code>brix.Indicator.return_indicator_numeric()</code>, <code>brix.Indicator.return_indicator_heatmap()</code>, and <code>brix.Indicator.return_indicator_textual()</code>. If you do not define a <code>brix.Indicator.return_indicator()</code> function, brix will run first the heatmap, then the numeric indicator, and finally the textual indicator. If you chose to have tighter control of the order in which the simulation runs, you can also define your own <code>brix.Indicator.return_indicator()</code> by calling these three functions. This function should return a dictionary with three keys: <code>heatmap</code>, <code>numeric</code>, and <code>textual</code>. Not all three keys have to be present. See the example below:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def return_indicator(self, geogrid_data):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">out = {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">out[&#x27;heatmap&#x27;] = self.return_indicator_heatmap(geogrid_data)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">out[&#x27;numeric&#x27;] = self.return_indicator_numeric(geogrid_data)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">out[&#x27;textual&#x27;] = self.return_indicator_textual(geogrid_data)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">return out</span></div></div></div></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="deploy-your-indicator"></a>Deploy your indicator<a aria-hidden="true" tabindex="-1" class="hash-link" href="#deploy-your-indicator" title="Direct link to heading">#</a></h2><p>Finally, once you have build a series of indicators, the right way to deploy them is to use the <code>brix.Handler</code> class. A <code>brix.Handler</code> object should be the go-to connection to the table and will handle all possible exceptions. The two most important methods are <code>brix.Handler.add_indicators()</code> which takes a list of <code>brix.Indicator</code> objects and connects them to the table, and <code>brix.Handler.listen()</code> that is a method that runs continuously waiting for updates in the CityScope table. This method can also creates its own thread, to free up the main thread in case the user needs to connect to other tables (by setting <code>new_thread=True</code>). The example below assumes you have already defined indicators named Density, Diversity and Proximity in a file named <code>myindicators.py</code>.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix import Handler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">from myindicators import Density, Diversity, Proximity</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">dens = Density()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">divs = Diversity()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">prox = Proximity()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(&#x27;dungeonmaster&#x27;, quietly=False)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.add_indicators([</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        dens,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        divs,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        prox</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.listen()</span></div></div></div></div></div><p>To see the indicators in the handler you can use <code>H.list_indicators()</code> to list the indicator names, and use <code>H.return_indicator(&lt;indicator_name&gt;)</code> to see the value of the indicator. Finally, the function <code>H.update_package()</code> will return the data that will be posted on CityIO.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="additional-tools"></a>Additional tools<a aria-hidden="true" tabindex="-1" class="hash-link" href="#additional-tools" title="Direct link to heading">#</a></h2><p>This module also contains a set of other useful functions that integrate with <code>brix.Handler</code> and <code>brix.Indicator</code>.</p><p>The functions <code>brix.get_OSM_geometries()</code> and <code>brix.get_OSM_nodes()</code> help you get data from Open Street Maps for your table.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="auto-updates-of-geogriddata"></a>Auto-updates of GEOGRIDDATA<a aria-hidden="true" tabindex="-1" class="hash-link" href="#auto-updates-of-geogriddata" title="Direct link to heading">#</a></h3><p>Brix also has the capability of automatically updating GEOGRIDDATA. For simple one-time updates, follow the documentation of <code>brix.Handler.update_geogrid_data()</code>. To use this feeature, you first need to define a function that takes a <code>brix.GEOGRIDDATA</code> as an input. When used with <code>brix.Handler.update_geogrid_data()</code>, this function can take any number of keyword arguments. The following example raises the height of all cells by 3 units:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def add_height(geogrid_data, levels=1):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for cell in geogrid_data:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                cell[&#x27;height&#x27;] += levels</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return geogrid_data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(&#x27;dungeonmaster&#x27;, quietly=False)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.update_geogrid_data(add_height,levels=3)</span></div></div></div></div></div><p>Brix also supports GEOGRIDDATA updates everytime there is a registered user interaction in the front end. To add a function to the update schedule, use <code>brix.Handler.add_geogrid_data_update_function()</code>. This has the limitation that your update funcion cannot take in any arguments other. If this limitation proves too restrictive, please submit an issue and weâ€™ll consider pushing an update.</p><p>The following example updates the whole grid to Light Industrial use everytime thereâ€™s a user interaction:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">def update_g(geogrid_data):</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for cell in geogrid_data:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                cell[&#x27;name&#x27;] = &#x27;Light Industrial&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return geogrid_data</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(table_name,quietly=False)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.add_geogrid_data_update_function(update_g)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.listen()</span></div></div></div></div></div><p>The updates triggered by <code>brix.Handler.listen()</code> follow the following order:</p><ol><li>get GEOGRIDDATA</li></ol><ol start="2"><li>run all GEOGRIDDATA updates using the result of 1 as input</li></ol><ol start="3"><li>get the new GEOGRIDDATA</li></ol><ol start="4"><li>update all indicators using the GEOGRIDDATA object resulting from 3</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="testing-your-module"></a>Testing your module<a aria-hidden="true" tabindex="-1" class="hash-link" href="#testing-your-module" title="Direct link to heading">#</a></h3><p>To automatically test your module, this library provides the <code>brix.User</code> class that simulates the behavior of a user interacting with your grid. This user runs in its own new thread to free up your main thread so that you can keep wokring on your indicator.</p><p>The following example consists of a <code>brix.Handler</code> that contains a diversity <code>brix.Indicator</code> that reponds to the updates of the <code>brix.User</code>:</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-undefined codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix import Handler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix.examples import Diversity</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">from brix.test_tools import User</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">table_name = &#x27;dungeonmaster&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">U = User(table_name)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H = Handler(table_name,quietly=False)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">div = Diversity()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.add_indicator(div)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">U.start_user()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">H.listen()</span></div></div></div></div></div></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/CityScope/cityscope.github.io/blob/new_docsite/docsite/docs/modules/Brix/Tutorial/Tutorial.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 40 40" style="margin-right:0.3em;vertical-align:sub"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#basics-of-building-a-cityscope-indicator" class="table-of-contents__link">Basics of building a CityScope indicator</a></li><li><a href="#lets-talk-data-input" class="table-of-contents__link">Letâ€™s talk data (input)</a></li><li><a href="#build-and-test-your-indicator-output" class="table-of-contents__link">Build and test your indicator (output)</a></li><li><a href="#deploy-your-indicator" class="table-of-contents__link">Deploy your indicator</a></li><li><a href="#additional-tools" class="table-of-contents__link">Additional tools</a><ul><li><a href="#auto-updates-of-geogriddata" class="table-of-contents__link">Auto-updates of GEOGRIDDATA</a></li><li><a href="#testing-your-module" class="table-of-contents__link">Testing your module</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="text--center"><div class="margin-bottom--sm"><a href="https://github.com/CityScope" target="_blank" rel="noopener noreferrer" class="footerLogoLink_1zJy"><img class="footer__logo" alt="Logo" src="/img/ML_logo_sml.png"></a></div><div>Copyright Â© 2021 CityScope, MIT City Science</div></div></div></footer></div>
<script src="/styles.ca97067b.js"></script>
<script src="/runtime~main.81a53239.js"></script>
<script src="/main.3dd27073.js"></script>
<script src="/1.0436ce2f.js"></script>
<script src="/2.5a76e39d.js"></script>
<script src="/30.bbda0e72.js"></script>
<script src="/935f2afb.3e860e5c.js"></script>
<script src="/17896441.cc98e1ce.js"></script>
<script src="/1c356875.afc84696.js"></script>
</body>
</html>