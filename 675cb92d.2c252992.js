(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{70:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return s}));var i=n(2),a=(n(0),n(86));const o={id:"GAMA"},r={unversionedId:"modules/GAMA",id:"modules/GAMA",isDocsHomePage:!1,title:"GAMA",description:"Agent-Based Model developped in the CityScience group using Gama Platform and integrated in CityScope",source:"@site/docs/modules/GAMA.md",slug:"/modules/GAMA",permalink:"/modules/GAMA",editUrl:"https://github.com/CityScope/cityscope.github.io/blob/new_docsite/docsite/docs/modules/GAMA.md",version:"current",sidebar:"sidebar",previous:{title:"Brix",permalink:"/modules/Brix/Brix"},next:{title:"CityIO",permalink:"/backend/CityIO"}},l=[{value:"Basics of building a CityScope indicator in GAMA",id:"basics-of-building-a-cityscope-indicator-in-gama",children:[]},{value:"GAMABrix for <code>cs-brix</code> users",id:"gamabrix-for-cs-brix-users",children:[]},{value:"The CityIO global",id:"the-cityio-global",children:[]},{value:"Let&#39;s talk input",id:"lets-talk-input",children:[]},{value:"Building an indicator (output)",id:"building-an-indicator-output",children:[]},{value:"Deploy your indicator",id:"deploy-your-indicator",children:[]},{value:"Basic numeric indicator",id:"basic-numeric-indicator",children:[]},{value:"Basic heatmap indicator",id:"basic-heatmap-indicator",children:[]},{value:"Basic agent indicator",id:"basic-agent-indicator",children:[]},{value:"Full module example (with comments)",id:"full-module-example-with-comments",children:[]}],c={rightToc:l};function s({components:e,...t}){return Object(a.b)("wrapper",Object(i.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Agent-Based Model developped in the ",Object(a.b)("a",{parentName:"p",href:"https://www.media.mit.edu/groups/city-science/overview/"},"CityScience")," group using ",Object(a.b)("a",{parentName:"p",href:"https://gama-platform.github.io/"},"Gama Platform")," and integrated in ",Object(a.b)("a",{parentName:"p",href:"https://www.media.mit.edu/projects/cityscope/overview/"},"CityScope")),Object(a.b)("h1",{id:"introduction"},"Introduction"),Object(a.b)("p",null,"What is this library for? If you have never heard of a CityScope before, you might want to stop reading and learn about them ",Object(a.b)("a",{parentName:"p",href:"https://cityscope.media.mit.edu/"},"here"),". CityScope is an awesome way to interact, explore, and co-create urban interventions in a way that can be accessed by multiple people with different background. If you know what they are, please keep reading."),Object(a.b)("p",null,"What is a CityScope table? a \u2018table\u2019 is our way of describing a CityScope project. Why table then? Since historically, most CityScope instances were composed of a mesh between a physical table-top 3D model of a city, augmented with projections, software, and other interface hardware. So a table => project."),Object(a.b)("p",null,"What is an indicator? An indicator is the result of running a module for CityScope. Indicators work by listening for updated from the CityScope table they are linked to, calculating some values by using a model, some function of the data, or a simulation, and then post the result of the calculations to CityIO to be displayed in the table."),Object(a.b)("p",null,"What are the types of indicators you can build? Indicators can be anything that could be displayed on a CityScope table, including the supporting screens associated to it. For the purpose of this library, we distinguish three types of indicator: numeric, heatmap, simulation."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Numeric: Numeric indicators are just a number or set of numbers. They are usually displayed in a chart (bar chart, radar chart, etc) next to the table. The most common numeric indicator are the numbers that go in the radar plot, which display information about density, diversity, and proximity.")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Heatmap: These indicators are geodata. They are made up of geometries (points, lines, or polygons) and properties associated to them. These indicators are displayed as layers directly on the CityScope table.")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Agent: These type of indicators are also displayed on the table but they are the result of an agent based simulation and are therefore displayed as a dynamic layer. They change over time like a short movie. ")),Object(a.b)("h1",{id:"setup"},"Setup"),Object(a.b)("p",null,"To setup GAMABrix copy the file ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix.gaml")," into your model directory and import it into your model. You can download ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix.gaml")," from ",Object(a.b)("a",{parentName:"p",href:"https://github.com/CityScope/CS_Simulation_GAMA/blob/master/CS_CityScope_GAMA/models/cityIO/models/GAMABrix.gaml"},"here")," Right after declaring your model, import the necessary species and functions by running:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'import "GAMABrix.gaml"\n')),Object(a.b)("p",null,"This will add to ",Object(a.b)("inlineCode",{parentName:"p"},"global")," the necessary functions to communicate with ",Object(a.b)("inlineCode",{parentName:"p"},"CityIO")," and two very important species that you will use to give your agents the properties they need to also live in CityIO: ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_numeric_indicator")," and ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent"),". Additionally, it sets up a series of ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents that will ensure your world is a copy of the world in the table you have selected."),Object(a.b)("h1",{id:"tutorial"},"Tutorial"),Object(a.b)("h2",{id:"basics-of-building-a-cityscope-indicator-in-gama"},"Basics of building a CityScope indicator in GAMA"),Object(a.b)("p",null,"Let\u2019s get to it. First, what table are you building for? If you don\u2019t have a specific table, that is totally okay and you can create one ",Object(a.b)("a",{parentName:"p",href:"https://cityscope.media.mit.edu/CS_cityscopeJS/"},"here"),". Note: by the time you read this, CityScope might pose some limitations on new projects (",Object(a.b)("inlineCode",{parentName:"p"},"tables"),"). Please follow instructions in the link above."),Object(a.b)("p",null,"For this tutorial, we crated one called ",Object(a.b)("inlineCode",{parentName:"p"},"dungeonmaster"),"."),Object(a.b)("p",null,"An indicator will basically take in the properties of the ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents in the world or the properties of any other simulated agent and produce a result. Each new indicator is built as an subclass of the ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," class. ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," is your friend, so we'll spend some time discussing it here."),Object(a.b)("p",null,"When you setup a model by importing ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix"),", the model will run for one whole day of simulation, then posts the results of this simulation to cityio, and then stay idle waiting for an update from the table. This can be a bit annoying when you are only starting to build your model, so you can turn off this behavior and just keep the local grid update. "),Object(a.b)("p",null,"Think of each indicator as an observer in your model that will report information back to CityIO. When it's a numeric indicator, the agent will just report a number that it calculates based on the ",Object(a.b)("inlineCode",{parentName:"p"},"brix"),"s, when it's a heatmap indicator, the agent will report some numbers along with its location, and when it's an agent, the agent will report it's location over time. ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," is used as the parent class of any species that you want to visualize in CityIO. There are some specific parameters your sub-species needs to define to set the agent as a numeric, heatmap, or agent indicator."),Object(a.b)("h2",{id:"gamabrix-for-cs-brix-users"},"GAMABrix for ",Object(a.b)("inlineCode",{parentName:"h2"},"cs-brix")," users"),Object(a.b)("p",null,"If you are familiar with the python library ",Object(a.b)("a",{parentName:"p",href:"https://cityscope.media.mit.edu/CS_Brix/"},"cs-brix"),", keep reading. Otherwise, skip to the next section of the tutorial. ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," is relies on defining classes that contain functions that take ",Object(a.b)("inlineCode",{parentName:"p"},"geogrid_data")," as an input. For ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," this is not necessary. Since ",Object(a.b)("inlineCode",{parentName:"p"},"GAMA")," relies on setting up a world with agents, the input data is already in the world in the form of ",Object(a.b)("inlineCode",{parentName:"p"},"brix"),". Therefore, when building urban indicators in ",Object(a.b)("inlineCode",{parentName:"p"},"GAMA")," you do not need to worry about input, and you can just get the necessary information from the ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents that will be automatically created in your world. "),Object(a.b)("p",null,"In terms of output, ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," relies on a series of return functions passed to a ",Object(a.b)("inlineCode",{parentName:"p"},"Handler")," class. In ",Object(a.b)("inlineCode",{parentName:"p"},"GAMA"),", the world itself acts as the ",Object(a.b)("inlineCode",{parentName:"p"},"Handler")," class, so there is no need to explicitly add your indicators to the ",Object(a.b)("inlineCode",{parentName:"p"},"Handler")," as they are already contained in the ",Object(a.b)("inlineCode",{parentName:"p"},"global")," species. The way to flag your indicators to be sent to ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO")," is to define them as a subclass of ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent"),". "),Object(a.b)("p",null,"While ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," can handle multiple tables at the same time by creating multiple threads for each ",Object(a.b)("inlineCode",{parentName:"p"},"Handler"),", ",Object(a.b)("inlineCode",{parentName:"p"},"GAMA")," is constrained to one table per model."),Object(a.b)("h2",{id:"the-cityio-global"},"The CityIO global"),Object(a.b)("p",null,"To connect your world to a table you need to declare the table name inside your ",Object(a.b)("inlineCode",{parentName:"p"},"global")," and set the geometry of your world based on this table. For example, we named our table ",Object(a.b)("inlineCode",{parentName:"p"},"dungeonmaster"),":"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'string city_io_table<-"dungeonmaster";\ngeometry shape <- envelope(setup_cityio_world());\n')),Object(a.b)("p",null,"While you are building your model, we recommend turning off ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," to speed up the process (the default). By setting ",Object(a.b)("inlineCode",{parentName:"p"},"post_on<-false"),", the model will only update your local grid without posting any of the indicators to cityio. In other words, you will only be ",Object(a.b)("em",{parentName:"p"},"getting")," from ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO")," not ",Object(a.b)("em",{parentName:"p"},"posting"),". This will reduce your bandwidth usage and allow you to debug your model faster. By doing this, the model will still keep track of the day and enter idle mode once the day is over. "),Object(a.b)("p",null,"For early stages of model building, you might also want to set ",Object(a.b)("inlineCode",{parentName:"p"},"pull_only<-true"),". This will tell turn off most of the functionality of the module and just make sure you are updating the local grid by pulling from your table. The simulation will not enter idle mode and the day will never reset. "),Object(a.b)("p",null,"Once you are done and want to deploy, change:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"bool post_on<-true;\n")),Object(a.b)("p",null,"Additionally, the following variables can be defined in the ",Object(a.b)("inlineCode",{parentName:"p"},"global")," and allow for a finer control of how the ",Object(a.b)("inlineCode",{parentName:"p"},"global")," communicates with ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),". You do not need to set them up now, as the default should work fine."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"city_io_table"),": String, name of the table to connect to."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"post_on"),": Boolean, used to turn the posting feature on or off. Keep it off while building the model and turn it on to post to the table."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"update_frequency"),": Intenger, frequency, in number of simulation ticks, by which to update local grid by checking for changes in gridhash. This is not the posting frequency. Optional, and defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"10"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"send_first_batch"),": Boolean, if ",Object(a.b)("inlineCode",{parentName:"li"},"false")," it will only send the results of the simulation once the full day has run. Optional and defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"true"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"cycle_first_batch"),": Integer, simulation tick in which to send the first batch of data to the server. Optional and defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"100"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"step"),": Float, time between two simulation ticks. Defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"60 #sec"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"saveLocationInterval"),": Float, frequency in second by which to save locally the location of agents. This is not the post frequency. Optional and defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"10")," steps.\t"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"totalTimeInSec"),": Integer, total time in seconds that the simulation will run for. Defaults to a whole day. Please note that ",Object(a.b)("inlineCode",{parentName:"li"},"CityIO")," will not render more than 1 day of simulation."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"idle_update_frequency"),": Float, time in real world seconds (not simulation seconds) between two get requests to check hash when in idle mode. "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"pull_only"),": Boolean, used to use GAMABrix only to update the local grid. This is very useful for the early stages of model building.")),Object(a.b)("p",null,"When you import ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," you will also see an additional experiment called ",Object(a.b)("inlineCode",{parentName:"p"},"CityScopeHeadless"),". This experiment is used to run your model as a headless process in a server."),Object(a.b)("p",null,"By default, ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," will run its init (which creates the grid) right after your model's init. This means that you will not have access to any ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," object inside your init. You can always change this behavior by forcing ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," to run its init earlyer by adding ",Object(a.b)("inlineCode",{parentName:"p"},"do brix_init")," where needed. "),Object(a.b)("h2",{id:"lets-talk-input"},"Let's talk input"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"GAMA")," will keep a copy of the ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO")," grid locally by creating the necessary ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents. This makes all the grid information accessible to all the agents by interacting with the ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents. "),Object(a.b)("p",null,"The main properties that ",Object(a.b)("inlineCode",{parentName:"p"},"brix")," agents have are:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"type: String that identifies the type of the block. This is editable (e.g. ",Object(a.b)("inlineCode",{parentName:"li"},"Residential"),")."),Object(a.b)("li",{parentName:"ul"},"height: Float, height of the block."),Object(a.b)("li",{parentName:"ul"},"color: RGB object."),Object(a.b)("li",{parentName:"ul"},"block_lbcs: ",Object(a.b)("inlineCode",{parentName:"li"},"map<string, float>")," Map that connects strings (LBCS codes) and float (proportion of the block in each code)."),Object(a.b)("li",{parentName:"ul"},"block_naics: ",Object(a.b)("inlineCode",{parentName:"li"},"map<string, float>")," Map that connects strings (NAICS codes) and float (proportion of the block in each code).")),Object(a.b)("p",null,"Note that ",Object(a.b)("inlineCode",{parentName:"p"},"block_lbcs")," and ",Object(a.b)("inlineCode",{parentName:"p"},"block_naics")," are the same for each ",Object(a.b)("inlineCode",{parentName:"p"},"type")," and are defined when you create the table. "),Object(a.b)("h2",{id:"building-an-indicator-output"},"Building an indicator (output)"),Object(a.b)("p",null,"Now, we'll turn some agents into observers that will report information to ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),". All three different types of indicators report different types of information, and an agent can be reporting any type of information to ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),"."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Numeric: Reports numbers (e.g. average commuting time, total energy consumption, etc.). Turn this on by setting ",Object(a.b)("inlineCode",{parentName:"li"},"is_numeric<-true"),"."),Object(a.b)("li",{parentName:"ul"},"Heatmap: Reports numbers with location (e.g. traffic in a particular intersection, total sunlight in a specific location). Turn this on by setting ",Object(a.b)("inlineCode",{parentName:"li"},"is_heatmap<-true"),"."),Object(a.b)("li",{parentName:"ul"},"Agent: Report all their locations during one whole day of simulation. Turn this on by setting ",Object(a.b)("inlineCode",{parentName:"li"},"is_visible<-true"),". Note that the variable ",Object(a.b)("inlineCode",{parentName:"li"},"is_visible")," refers only to wether you'll see the agent in your CityScope table. You still need to ",Object(a.b)("inlineCode",{parentName:"li"},"display")," them in your local GAMA interfase if you want to see them. ")),Object(a.b)("p",null,"When creating a numeric indicator you need to write a ",Object(a.b)("inlineCode",{parentName:"p"},"reflex")," for your agent that updates either ",Object(a.b)("inlineCode",{parentName:"p"},"numeric_values")," or ",Object(a.b)("inlineCode",{parentName:"p"},"heatmap_values"),". These two variables should be ",Object(a.b)("inlineCode",{parentName:"p"},"map<string,float>"),". Here is a simple example that ",Object(a.b)("inlineCode",{parentName:"p"},"numeric_values")," with the number of blocks."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'reflex update_numeric {\n    numeric_values<-[];\n    numeric_values<+"Number of blocks"::length(brix);\n}\n')),Object(a.b)("p",null,"Similarly, here is another example that updates ",Object(a.b)("inlineCode",{parentName:"p"},"heatmap_values")," with two layers, ",Object(a.b)("inlineCode",{parentName:"p"},"heat")," and ",Object(a.b)("inlineCode",{parentName:"p"},"map")," defined as random numbers:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'reflex update_heatmap {\n    heatmap_values<-[];\n    heatmap_values<+ "heat"::rnd(10);\n    heatmap_values<+ "map"::rnd(10);\n}\n')),Object(a.b)("p",null,"For an agent indicator there is no value to be updated, as the indicator just reports its location. However, if your agent does not move, you will get a very boring dot so you might want to update the location. Here is a simple ",Object(a.b)("inlineCode",{parentName:"p"},"reflex")," that updates the location:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"reflex move{\n    do wander;\n}\n")),Object(a.b)("p",null,"Additionally, ",Object(a.b)("inlineCode",{parentName:"p"},"GAMABrix")," provides a shortcut to create numeric indicators that do not require you to define a subspecies. This is meant for straightforward indicators that can be calculated in one line of code. To create a simple numeric indicator, just create and agent of the ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_numeric_indicator")," species and pass your function as a string to ",Object(a.b)("inlineCode",{parentName:"p"},"indicator_value"),". For example, a numeric indicator that returns the average height of blocks:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'create cityio_numeric_indicator with: (viz_type:"bar",indicator_name: "Mean Height", indicator_value: "mean(brix collect each.height)");\n')),Object(a.b)("h2",{id:"deploy-your-indicator"},"Deploy your indicator"),Object(a.b)("p",null,"Let's say you finished writing your model and are ready to leave it running forever (in a server with ssh access, for example). "),Object(a.b)("p",null,"We highly recommend using a docker container to run headless GAMA on a server. This will take care of compatibility issues between platforms. "),Object(a.b)("p",null,"First, pull the image from dockerhub. This step only needs to be performed once per server. We will be using ",Object(a.b)("a",{parentName:"p",href:"https://hub.docker.com/r/gamaplatform/gama"},"this image"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"> docker pull gamaplatform/gama\n")),Object(a.b)("p",null,"Second, we will build the ",Object(a.b)("inlineCode",{parentName:"p"},"xml")," file with the model meta parameters. You will only need to do this once for each model. Ensure you model directory (the folder that contains models, results, etc) contains a ",Object(a.b)("inlineCode",{parentName:"p"},"headless")," folder, and then run the following command adding the name of your gama file (",Object(a.b)("inlineCode",{parentName:"p"},"model_file.gaml"),") where needed:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'> docker run --rm -v "$(pwd)":/usr/lib/gama/headless/my_model gamaplatform/gama -xml CityScopeHeadless my_model/models/[model_file.gaml] my_model/headless/myHeadlessModel.xml\n')),Object(a.b)("p",null,"This creates a file called ",Object(a.b)("inlineCode",{parentName:"p"},"myHeadlessModel.xml")," in your ",Object(a.b)("inlineCode",{parentName:"p"},"headless")," folder. If you know how to edit this file, feel free to modify it now. For more information about this file, check the ",Object(a.b)("a",{parentName:"p",href:"https://gama-platform.github.io/wiki/Headless"},"documentation"),". Please note that by default the simulation will only run 1000 steps. If you wish to change this, edit the ",Object(a.b)("inlineCode",{parentName:"p"},"xml")," and change the ",Object(a.b)("inlineCode",{parentName:"p"},"finalStep")," property to a higher number or just delete if you wish the model to run continuosly."),Object(a.b)("p",null,"Finally, we will run this model inside a container. This final step is what you will repeat everytime you modify your model. Run the following command, again from your model director:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'> docker run --rm -v "$(pwd)":/usr/lib/gama/headless/my_model gamaplatform/gama my_model/headless/myHeadlessModel.xml my_model/results/\n')),Object(a.b)("h1",{id:"examples"},"Examples"),Object(a.b)("h2",{id:"basic-numeric-indicator"},"Basic numeric indicator"),Object(a.b)("p",null,"To create a numeric indicator, the recommended way is to define a species of agents that will act as ",Object(a.b)("em",{parentName:"p"},"observers")," that will report the information to ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),". This species needs to have ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," as parent species."),Object(a.b)("p",null,"You need to define four things:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Set ",Object(a.b)("inlineCode",{parentName:"li"},"is_numeric")," to ",Object(a.b)("inlineCode",{parentName:"li"},"true"),"."),Object(a.b)("li",{parentName:"ul"},"Define a reflex that updates the ",Object(a.b)("inlineCode",{parentName:"li"},"numeric_values")," map (",Object(a.b)("inlineCode",{parentName:"li"},"map<string,float>"),")."),Object(a.b)("li",{parentName:"ul"},"Define an ",Object(a.b)("inlineCode",{parentName:"li"},"indicator_name")," either in the species definition or in the create statement."),Object(a.b)("li",{parentName:"ul"},"Set the ",Object(a.b)("inlineCode",{parentName:"li"},"viz_type")," to either ",Object(a.b)("inlineCode",{parentName:"li"},"bar")," or ",Object(a.b)("inlineCode",{parentName:"li"},"radar")," (defaults to ",Object(a.b)("inlineCode",{parentName:"li"},"bar")," if you don't change it).")),Object(a.b)("p",null,"Here's a simple example:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'species my_numeric_indicator parent: cityio_agent {\n    bool is_numeric<-true;\n    string viz_type <- "bar";\n    string indicator_name<-"Table Size";\n    \n    reflex update_numeric {\n        numeric_values<-[];\n        numeric_values<+indicator_name::length(brix);\n    }\n}\n')),Object(a.b)("p",null,"Don't forget to create an agent of this species in the ",Object(a.b)("inlineCode",{parentName:"p"},"global")," ",Object(a.b)("inlineCode",{parentName:"p"},"init"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"create my_numeric_indicator;\n")),Object(a.b)("p",null,"For simple indicators, you can rely on creating an agent of the ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_numeric_indicator")," species in your ",Object(a.b)("inlineCode",{parentName:"p"},"global")," ",Object(a.b)("inlineCode",{parentName:"p"},"init"),". Here's an example:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'create cityio_numeric_indicator with: (viz_type:"bar", indicator_name: "Max Height",  indicator_value: "max(brix collect each.height)");\n')),Object(a.b)("h2",{id:"basic-heatmap-indicator"},"Basic heatmap indicator"),Object(a.b)("p",null,"To create a heatmap indicator, define a species of agents that will act as ",Object(a.b)("em",{parentName:"p"},"observers")," that will report the information to ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),". These agents need to have a location assigned to them. This species needs to have ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," as parent species."),Object(a.b)("p",null,"You need to define three things:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Set ",Object(a.b)("inlineCode",{parentName:"li"},"is_heatmap")," to ",Object(a.b)("inlineCode",{parentName:"li"},"true"),"."),Object(a.b)("li",{parentName:"ul"},"Define a reflex that updates the ",Object(a.b)("inlineCode",{parentName:"li"},"heatmap_values")," map (",Object(a.b)("inlineCode",{parentName:"li"},"map<string,float>"),")."),Object(a.b)("li",{parentName:"ul"},"Define an ",Object(a.b)("inlineCode",{parentName:"li"},"indicator_name")," either in the species definition or in the create statement.")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'species thermometer parent: cityio_agent {\n    bool is_heatmap<-true;\n    string indicator_name<-"thermometer";\n    \n    reflex update_heatmap {\n        heatmap_values<-[];\n        heatmap_values<+ "heat"::rnd(10);\n        heatmap_values<+ "map"::rnd(10);\n    }   \n}\n')),Object(a.b)("h2",{id:"basic-agent-indicator"},"Basic agent indicator"),Object(a.b)("p",null,"Finally, you can easily add agents to be displayed in ",Object(a.b)("inlineCode",{parentName:"p"},"cityIO"),". Interestingly, these are the easiest indicators to define. In fact, you can turn any species into a ",Object(a.b)("inlineCode",{parentName:"p"},"cityio_agent")," by defining their parent class. "),Object(a.b)("p",null,"You need to is_visible two things:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Set ",Object(a.b)("inlineCode",{parentName:"li"},"is_heatmap")," to ",Object(a.b)("inlineCode",{parentName:"li"},"true"),"."),Object(a.b)("li",{parentName:"ul"},"Define a reflex that updates the agent's location. ")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},"species people parent: cityio_agent skills:[moving]{ \n    bool is_visible<-true;\n    \n    reflex move{\n        do wander;\n    }\n}\n")),Object(a.b)("p",null,"Additionally, you can define the integers ",Object(a.b)("inlineCode",{parentName:"p"},"profile")," and ",Object(a.b)("inlineCode",{parentName:"p"},"mode")," that will control the way they are displayed in the front end. You can also define reflexes that update these two properties. For example, you can differentiate between drivers and walkers, or between day workers and night workers, etc. "),Object(a.b)("h2",{id:"full-module-example-with-comments"},"Full module example (with comments)"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre"},'model citIOGAMA\n\n// Import GAMABrix (this needs to be in the same directory as your model)\nimport "GAMABrix.gaml" \n\nglobal {\n    // Define the table you\'ll be working with\n    string city_io_table<-"dungeonmaster";\n    geometry shape <- envelope(setup_cityio_world());\n\n    // Set post to true so that GAMABrix can post to cityIO\n    bool post_on<-true;\n    \n    init {\n        // Create people based on species defined below\n        create people number:10; \n\n        // Create 100 points of a heatmap indicator (species defined below)\n        create thermometer number:100;\n\n        // Use cityio_numeric_indicator to define a mean block height numeric indicator\n        create cityio_numeric_indicator with: (viz_type:"bar",indicator_name: "Mean Height", indicator_value: "mean(brix collect each.height)");\n        \n        // Create a numeric indicator based on the species defined below\n        create my_numeric_indicator     with: (viz_type:"bar",indicator_name: "Number of blocks");\n    }\n    \n    \n}\n\n// Define a custom numeric indicator\nspecies my_numeric_indicator parent: cityio_agent {\n    // Set the indicator as numeric\n    bool is_numeric<-true;\n\n    // Visualize it as a bar chart\n    string viz_type <- "bar";\n    \n    // Define reflex that updates numeric_values\n    reflex update_numeric {\n        numeric_values<-[];\n        numeric_values<+indicator_name::length(brix);\n    }\n}\n\n// Define custom heatmap indicator\nspecies thermometer parent: cityio_agent {\n    // Set the indicator as heatmap\n    bool is_heatmap<-true;\n\n    // Define reflex that updates heatmap_values\n    reflex update_heatmap {\n        heatmap_values<-[];\n        heatmap_values<+ "heat"::rnd(10);\n        heatmap_values<+ "map"::rnd(10);\n    }   \n}\n\n// Define people, to be used as agent indicators\nspecies people parent: cityio_agent skills:[moving]{ \n    // Set agents as visible in cityIO\n    bool is_visible<-true;\n    \n    // Update the agents location at every step\n    reflex move{\n        do wander;\n    }\n    \n    // Set base aspect to visualize in GAMA GUI\n    aspect base{\n        draw circle(10) color:#blue;\n    }\n}\n\n// Define a experiment to visualize in GUI\nexperiment CityScope type: gui autorun:false{\n    output {\n        display map_mode type:opengl background:#black{ \n            species brix aspect:base;\n            species people aspect:base position:{0,0,0.1};\n        }\n    }\n}\n')))}s.isMDXComponent=!0},86:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var i=n(0),a=n.n(i);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),b=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=b(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(n),u=i,m=p["".concat(r,".").concat(u)]||p[u]||d[u]||o;return n?a.a.createElement(m,l(l({ref:t},s),{},{components:n})):a.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);